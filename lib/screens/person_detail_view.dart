import 'package:firetown/providers/barrel_of_providers.dart';
import 'package:flutter/material.dart';
// import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
// import 'package:firetown/navrail.dart';
import 'package:firetown/screens/person_edit.dart';
// import 'load_json.dart';

// import 'shop.dart';
// import 'person.dart';
// import 'bottombar.dart';
import "../globals.dart";
import "../models/relationships_model.dart";
import '../services/description_service.dart';
// import "editHelpers.dart";

class PersonDetailView extends HookConsumerWidget {
  const PersonDetailView({super.key,ar});
  static const routeName="/persondetailview";
  
  
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final arguments = ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    final myID = arguments?['myID'];
    
    final people = ref.watch(peopleProvider);

    final personIndex=people.indexWhere((p)=> p.id==myID);

 
    
    
    return Scaffold(
    appBar: AppBar(
      title: Text("Details for ${people[personIndex].firstName} ${people[personIndex].surname}"),
    ),
      body: GestureDetector(
      onTap: () => FocusScope.of(context).unfocus(),
      child: Scaffold(
        body: ListView(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 40),
          children: [
            FilledButton.tonal( onPressed: 
              () {navigatorKey.currentState!.restorablePushNamed(
                  PersonEditView.routeName,
                  arguments: {
                    'myID': people[personIndex].id,
                  }
              );
                }
                ,
                child: const Icon(Icons.edit)
                ),
            const SizedBox(height: 42),
            if (people.isNotEmpty) const Divider(height: 0),
            ProviderScope(
                overrides:[currentPerson.overrideWithValue(people[personIndex]),
                ],
                child: const PersonDetailItem(),
            )
            ],
        ),
      ),
    )
    );
  }
}

class PersonDetailItem extends HookConsumerWidget {
  const PersonDetailItem({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final person = ref.watch(currentPerson);
    final people = ref.watch(peopleProvider);
    final relations = ref.watch(relationshipsProvider);
    // Use firstWhere with orElse to handle missing nodes, and deduplicate if needed
    Node? myNode;
    final matchingNodes = relations.where((n) => n.id == person.id).toList();
    
    if (matchingNodes.isEmpty) {
      // No node exists, create an empty one for display purposes
      myNode = Node(id: person.id, relPairs: {});
    } else if (matchingNodes.length == 1) {
      // Perfect - exactly one node as expected
      myNode = matchingNodes.first;
    } else {
      // Multiple nodes found - this indicates the duplicate bug
      debugPrint("WARNING: Found ${matchingNodes.length} nodes for person ${person.id}. Using first one and suggesting cleanup.");
      myNode = matchingNodes.first;
      
      // Trigger cleanup of duplicates
      WidgetsBinding.instance.addPostFrameCallback((_) {
        ref.read(relationshipsProvider.notifier).deduplicateNodes();
      });
    }
    
  return SingleChildScrollView(
    child:Material(
      color: Colors.white,
      elevation: 6,
        child: GestureDetector(
          onTap: () {
            // ignore: avoid_print
            print(person.firstName);
          },
            child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              ...person.printDetail(people,myNode),
              // Add description section
              const SizedBox(height: 16),
              _buildDescriptionSection(context, ref, person),
              // Auto-generate descriptions if empty
              _autoGenerateDescriptions(ref, person),
            ],
          ),
         
        ),

    )
  );
  }

  Widget _buildDescriptionSection(BuildContext context, WidgetRef ref, person) {
    final physicalTraits = person.physicalTraits.map((t) => t.description).toList();
    final clothingTraits = person.clothingTraits.map((t) => t.description).toList();
    
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Character Description',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                IconButton(
                  icon: const Icon(Icons.refresh),
                  tooltip: 'Regenerate all descriptions',
                  onPressed: () => _regenerateAllDescriptions(ref, person),
                ),
              ],
            ),
            const SizedBox(height: 12),
            if (physicalTraits.isNotEmpty) ...[
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'Physical Traits',
                    style: Theme.of(context).textTheme.labelLarge?.copyWith(
                      color: Colors.blue[700],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.add_circle_outline, size: 20),
                    tooltip: 'Add more physical traits',
                    onPressed: () => _addMorePhysicalTraits(ref, person),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              ...physicalTraits.asMap().entries.map((entry) => 
                _buildTraitBullet(
                  context, 
                  entry.value, 
                  'physical', 
                  entry.key,
                  ref, 
                  person,
                ),
              ),
              const SizedBox(height: 12),
            ],
            if (clothingTraits.isNotEmpty) ...[
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'Clothing & Style',
                    style: Theme.of(context).textTheme.labelLarge?.copyWith(
                      color: Colors.green[700],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.add_circle_outline, size: 20),
                    tooltip: 'Add more clothing traits',
                    onPressed: () => _addMoreClothingTraits(ref, person),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              ...clothingTraits.asMap().entries.map((entry) => 
                _buildTraitBullet(
                  context, 
                  entry.value, 
                  'clothing', 
                  entry.key,
                  ref, 
                  person,
                ),
              ),
              const SizedBox(height: 12),
            ],
            if (physicalTraits.isEmpty && clothingTraits.isEmpty) ...[
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey.shade300),
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.grey.shade50,
                ),
                child: Text(
                  'Character descriptions will be generated automatically...',
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontStyle: FontStyle.italic,
                  ),
                  textAlign: TextAlign.center,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildDescriptionField(
    BuildContext context,
    String label,
    String? description,
    {VoidCallback? onReroll}
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              label,
              style: Theme.of(context).textTheme.labelLarge,
            ),
            if (description != null && onReroll != null)
              IconButton(
                icon: const Icon(Icons.casino, size: 16),
                tooltip: 'Reroll this description',
                onPressed: onReroll,
              ),
          ],
        ),
        const SizedBox(height: 4),
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            border: Border.all(color: Colors.grey.shade300),
            borderRadius: BorderRadius.circular(8),
            color: description == null ? Colors.grey.shade50 : Colors.white,
          ),
          child: Text(
            description ?? 'No description generated',
            style: TextStyle(
              fontSize: 14,
              color: description == null ? Colors.grey.shade600 : Colors.black87,
              fontStyle: description == null ? FontStyle.italic : FontStyle.normal,
            ),
          ),
        ),
      ],
    );
  }

  void _generateDescriptions(WidgetRef ref, person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty && clothingTemplates.isEmpty) {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No templates available. Please import templates first.'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }
      
      // Generate full description combining physical and clothing (for future use)
      // final fullDescription = descriptionService.generateFullDescription(
      //   person: person,
      //   physicalTemplates: physicalTemplates,
      //   clothingTemplates: clothingTemplates,
      //   allAncestries: allAncestryNames,
      //   maxTraits: 3,
      // );
      
      // Also generate individual descriptions
      final physicalDesc = physicalTemplates.isNotEmpty
          ? descriptionService.generatePhysicalDescription(
              person: person,
              templates: physicalTemplates,
              allAncestries: allAncestryNames,
            )
          : null;
          
      final clothingDesc = clothingTemplates.isNotEmpty
          ? descriptionService.generateClothingDescription(
              person: person,
              templates: clothingTemplates,
              allAncestries: allAncestryNames,
            )
          : null;
      
      // Update the person with new descriptions
      final peopleNotifier = ref.read(peopleProvider.notifier);
      final updatedPerson = person.copyWith(
        // Using trait-based system now
      );
      
      peopleNotifier.replace(person, updatedPerson);
      await peopleNotifier.commitChanges();
      
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text(
            'Generated descriptions using ${physicalTemplates.length} physical and ${clothingTemplates.length} clothing templates'
          ),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text('Error generating descriptions: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _regenerateDescriptions(WidgetRef ref, person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty && clothingTemplates.isEmpty) {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No templates available. Please import templates first.'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }
      
      // Regenerate both descriptions with new random selections
      final physicalDesc = physicalTemplates.isNotEmpty
          ? descriptionService.generatePhysicalDescription(
              person: person,
              templates: physicalTemplates,
              allAncestries: allAncestryNames,
            )
          : person.physicalDescription;
          
      final clothingDesc = clothingTemplates.isNotEmpty
          ? descriptionService.generateClothingDescription(
              person: person,
              templates: clothingTemplates,
              allAncestries: allAncestryNames,
            )
          : person.clothingDescription;
      
      // Update the person with regenerated descriptions
      final peopleNotifier = ref.read(peopleProvider.notifier);
      final updatedPerson = person.copyWith(
        physicalDescription: physicalDesc,
        clothingDescription: clothingDesc,
      );
      
      peopleNotifier.replace(person, updatedPerson);
      await peopleNotifier.commitChanges();
      
      ScaffoldMessenger.of(ref.context).showSnackBar(
        const SnackBar(
          content: Text('Descriptions regenerated with new random traits'),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text('Error regenerating descriptions: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _rerollPhysicalDescription(WidgetRef ref, person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty) {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No physical templates available. Please import templates first.'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }
      
      // Generate new physical description
      final newPhysicalDesc = descriptionService.generatePhysicalDescription(
        person: person,
        templates: physicalTemplates,
        allAncestries: allAncestryNames,
      );
      
      if (newPhysicalDesc != null) {
        // Update only the physical description
        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          physicalDescription: newPhysicalDesc,
        );
        
        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();
        
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('Physical description rerolled'),
            backgroundColor: Colors.green,
          ),
        );
      } else {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No suitable physical templates found for this character'),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text('Error rerolling physical description: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _rerollClothingDescription(WidgetRef ref, person) async {
    try {
      final descriptionService = DescriptionService();
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (clothingTemplates.isEmpty) {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No clothing templates available. Please import templates first.'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }
      
      // Generate new clothing description
      final newClothingDesc = descriptionService.generateClothingDescription(
        person: person,
        templates: clothingTemplates,
        allAncestries: allAncestryNames,
      );
      
      if (newClothingDesc != null) {
        // Update only the clothing description
        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          clothingDescription: newClothingDesc,
        );
        
        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();
        
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('Clothing description rerolled'),
            backgroundColor: Colors.green,
          ),
        );
      } else {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No suitable clothing templates found for this character'),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text('Error rerolling clothing description: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  // Helper method to parse descriptions into individual traits
  List<String> _parseDescriptionTraits(String? description) {
    if (description == null || description.isEmpty) {
      return [];
    }
    
    // Split by sentence-ending punctuation and clean up
    return description
        .split(RegExp(r'[.!?]+'))
        .map((trait) => trait.trim())
        .where((trait) => trait.isNotEmpty)
        .toList();
  }

  // Build a single trait bullet point with reroll button
  Widget _buildTraitBullet(
    BuildContext context,
    String trait,
    String type, // 'physical' or 'clothing'
    int index,
    WidgetRef ref,
    dynamic person,
  ) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            margin: const EdgeInsets.only(top: 8, right: 8),
            width: 4,
            height: 4,
            decoration: BoxDecoration(
              color: type == 'physical' ? Colors.blue[700] : Colors.green[700],
              shape: BoxShape.circle,
            ),
          ),
          Expanded(
            child: Text(
              trait,
              style: const TextStyle(fontSize: 14, height: 1.4),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.casino, size: 16),
            tooltip: 'Reroll this trait',
            onPressed: () => _rerollSpecificTrait(ref, person, type, index),
            constraints: const BoxConstraints(
              minWidth: 24,
              minHeight: 24,
            ),
            padding: const EdgeInsets.all(4),
          ),
        ],
      ),
    );
  }

  // Auto-generate descriptions if empty
  Widget _autoGenerateDescriptions(WidgetRef ref, dynamic person) {
    // Auto-generate if both descriptions are empty or null
    if (person.physicalTraits.isEmpty && person.clothingTraits.isEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _generateInitialDescriptions(ref, person);
      });
    }
    return const SizedBox.shrink();
  }

  // Reroll a specific trait by index and type
  void _rerollSpecificTrait(WidgetRef ref, dynamic person, String type, int traitIndex) async {
    try {
      final descriptionService = DescriptionService();
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      String? newDescription;
      String currentDescription = '';
      
      if (type == 'physical') {
        final physicalTemplates = ref.read(physicalTemplatesProvider);
        if (physicalTemplates.isEmpty) {
          _showTemplateError(ref, 'No physical templates available');
          return;
        }
        
        currentDescription = person.physicalTraits.isNotEmpty ? person.physicalTraits.first.description : '';
        newDescription = descriptionService.generatePhysicalDescription(
          person: person,
          templates: physicalTemplates,
          allAncestries: allAncestryNames,
        );
      } else if (type == 'clothing') {
        final clothingTemplates = ref.read(clothingTemplatesProvider);
        if (clothingTemplates.isEmpty) {
          _showTemplateError(ref, 'No clothing templates available');
          return;
        }
        
        currentDescription = person.clothingTraits.isNotEmpty ? person.clothingTraits.first.description : '';
        newDescription = descriptionService.generateClothingDescription(
          person: person,
          templates: clothingTemplates,
          allAncestries: allAncestryNames,
        );
      }
      
      if (newDescription != null && newDescription != currentDescription) {
        // Parse the new description and replace just the specific trait
        final newTraits = _parseDescriptionTraits(newDescription);
        final currentTraits = _parseDescriptionTraits(currentDescription);
        
        if (newTraits.isNotEmpty && traitIndex < currentTraits.length) {
          // Replace the specific trait with a random new one
          final updatedTraits = List<String>.from(currentTraits);
          if (newTraits.isNotEmpty) {
            updatedTraits[traitIndex] = newTraits.first;
          }
          
          final updatedDescription = updatedTraits.join('. ') + '.';
          
          // Update the person
          final peopleNotifier = ref.read(peopleProvider.notifier);
          final updatedPerson = type == 'physical'
              ? person // TODO: Update to use traits
              : person; // TODO: Update to use traits
          
          peopleNotifier.replace(person, updatedPerson);
          await peopleNotifier.commitChanges();
        }
      }
    } catch (e) {
      _showError(ref, 'Error rerolling trait: $e');
    }
  }

  // Add more traits from unused tags
  void _addMoreTraits(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      // Find used tags
      final usedTags = <String>{};
      final currentPhysical = person.physicalTraits.map((t) => t.description).toList();
      final currentClothing = person.clothingTraits.map((t) => t.description).toList();
      
      // Generate new traits from unused templates
      String? newPhysicalTrait;
      String? newClothingTrait;
      
      if (physicalTemplates.isNotEmpty) {
        newPhysicalTrait = descriptionService.generatePhysicalDescription(
          person: person,
          templates: physicalTemplates,
          allAncestries: allAncestryNames,
          excludeTags: usedTags.toList(),
        );
      }
      
      if (clothingTemplates.isNotEmpty) {
        newClothingTrait = descriptionService.generateClothingDescription(
          person: person,
          templates: clothingTemplates,
          allAncestries: allAncestryNames,
          excludeTags: usedTags.toList(),
        );
      }
      
      // Add new traits to existing descriptions
      final peopleNotifier = ref.read(peopleProvider.notifier);
      final updatedPhysical = newPhysicalTrait != null
          ? (currentPhysical + _parseDescriptionTraits(newPhysicalTrait)).join('. ') + '.'
          : person.physicalDescription;
      final updatedClothing = newClothingTrait != null
          ? (currentClothing + _parseDescriptionTraits(newClothingTrait)).join('. ') + '.'
          : person.clothingDescription;
      
      final updatedPerson = person.copyWith(
        physicalDescription: updatedPhysical,
        clothingDescription: updatedClothing,
      );
      
      peopleNotifier.replace(person, updatedPerson);
      await peopleNotifier.commitChanges();
      
      _showSuccess(ref, 'Added new traits to description');
    } catch (e) {
      _showError(ref, 'Error adding more traits: $e');
    }
  }

  // Regenerate all descriptions
  void _regenerateAllDescriptions(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty && clothingTemplates.isEmpty) {
        _showTemplateError(ref, 'No templates available');
        return;
      }
      
      final newPhysical = physicalTemplates.isNotEmpty
          ? descriptionService.generatePhysicalDescription(
              person: person,
              templates: physicalTemplates,
              allAncestries: allAncestryNames,
            )
          : person.physicalDescription;
          
      final newClothing = clothingTemplates.isNotEmpty
          ? descriptionService.generateClothingDescription(
              person: person,
              templates: clothingTemplates,
              allAncestries: allAncestryNames,
            )
          : person.clothingDescription;
      
      final peopleNotifier = ref.read(peopleProvider.notifier);
      final updatedPerson = person.copyWith(
        physicalDescription: newPhysical,
        clothingDescription: newClothing,
      );
      
      peopleNotifier.replace(person, updatedPerson);
      await peopleNotifier.commitChanges();
      
      _showSuccess(ref, 'All descriptions regenerated');
    } catch (e) {
      _showError(ref, 'Error regenerating descriptions: $e');
    }
  }

  // Generate initial descriptions for new characters
  void _generateInitialDescriptions(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty && clothingTemplates.isEmpty) {
        return; // No templates available, skip auto-generation
      }
      
      String? physicalDesc;
      String? clothingDesc;
      
      if (physicalTemplates.isNotEmpty && person.physicalTraits.isEmpty) {
        physicalDesc = descriptionService.generatePhysicalDescription(
          person: person,
          templates: physicalTemplates,
          allAncestries: allAncestryNames,
        );
      }
      
      if (clothingTemplates.isNotEmpty && person.clothingTraits.isEmpty) {
        clothingDesc = descriptionService.generateClothingDescription(
          person: person,
          templates: clothingTemplates,
          allAncestries: allAncestryNames,
        );
      }
      
      if (physicalDesc != null || clothingDesc != null) {
        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          // TODO: Update to use trait-based system
        );
        
        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();
      }
    } catch (e) {
      // Silent fail for auto-generation
      debugPrint('Auto-generation failed: $e');
    }
  }

  // Helper methods for showing messages
  void _showError(WidgetRef ref, String message) {
    ScaffoldMessenger.of(ref.context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
      ),
    );
  }

  void _showTemplateError(WidgetRef ref, String message) {
    ScaffoldMessenger.of(ref.context).showSnackBar(
      SnackBar(
        content: Text('$message. Please import templates first.'),
        backgroundColor: Colors.orange,
      ),
    );
  }

  void _showSuccess(WidgetRef ref, String message) {
    ScaffoldMessenger.of(ref.context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green,
      ),
    );
  }
  void _addMorePhysicalTraits(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();

      if (physicalTemplates.isEmpty) {
        _showTemplateError(ref, 'No physical templates available');
        return;
      }

      final newPhysicalTrait = descriptionService.generatePhysicalDescription(
        person: person,
        templates: physicalTemplates,
        allAncestries: allAncestryNames,
      );

      if (newPhysicalTrait != null) {
        final currentTraits = _parseDescriptionTraits(person.physicalDescription);
        final newTraits = _parseDescriptionTraits(newPhysicalTrait);
        final combinedTraits = [...currentTraits, ...newTraits];
        final updatedDescription = combinedTraits.join('. ') + '.';

        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          physicalDescription: updatedDescription,
        );

        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();

        _showSuccess(ref, 'Added new physical trait');
      } else {
        _showError(ref, 'No new physical traits available');
      }
    } catch (e) {
      _showError(ref, 'Error adding physical trait: $e');
    }
  }

  // Add more clothing traits from unused tags
  void _addMoreClothingTraits(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();

      if (clothingTemplates.isEmpty) {
        _showTemplateError(ref, 'No clothing templates available');
        return;
      }

      final newClothingTrait = descriptionService.generateClothingDescription(
        person: person,
        templates: clothingTemplates,
        allAncestries: allAncestryNames,
      );

      if (newClothingTrait != null) {
        final currentTraits = _parseDescriptionTraits(person.clothingDescription);
        final newTraits = _parseDescriptionTraits(newClothingTrait);
        final combinedTraits = [...currentTraits, ...newTraits];
        final updatedDescription = combinedTraits.join('. ') + '.';

        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          clothingDescription: updatedDescription,
        );

        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();

        _showSuccess(ref, 'Added new clothing trait');
      } else {
        _showError(ref, 'No new clothing traits available');
      }
    } catch (e) {
      _showError(ref, 'Error adding clothing trait: $e');
    }
  }
}

