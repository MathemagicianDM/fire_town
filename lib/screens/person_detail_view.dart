import 'package:firetown/providers/barrel_of_providers.dart';
import 'package:flutter/material.dart';
// import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
// import 'package:firetown/navrail.dart';
import 'package:firetown/screens/person_edit.dart';
// import 'load_json.dart';

// import 'shop.dart';
// import 'person.dart';
// import 'bottombar.dart';
import "../globals.dart";
import "../models/relationships_model.dart";
import "../models/character_trait_model.dart";
import '../services/description_service.dart';
import '../models/person_model.dart';
// import "editHelpers.dart";

class PersonDetailView extends HookConsumerWidget {
  const PersonDetailView({super.key,ar});
  static const routeName="/persondetailview";
  
  
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final arguments = ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    final myID = arguments?['myID'];
    
    final people = ref.watch(peopleProvider);

    final personIndex=people.indexWhere((p)=> p.id==myID);

 
    
    
    return Scaffold(
    appBar: AppBar(
      title: Text("Details for ${people[personIndex].firstName} ${people[personIndex].surname}"),
    ),
      body: GestureDetector(
      onTap: () => FocusScope.of(context).unfocus(),
      child: Scaffold(
        body: ListView(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 40),
          children: [
            FilledButton.tonal( onPressed: 
              () {navigatorKey.currentState!.restorablePushNamed(
                  PersonEditView.routeName,
                  arguments: {
                    'myID': people[personIndex].id,
                  }
              );
                }
                ,
                child: const Icon(Icons.edit)
                ),
            const SizedBox(height: 42),
            if (people.isNotEmpty) const Divider(height: 0),
            ProviderScope(
                overrides:[currentPerson.overrideWithValue(people[personIndex]),
                ],
                child: const PersonDetailItem(),
            )
            ],
        ),
      ),
    )
    );
  }
}

class PersonDetailItem extends ConsumerStatefulWidget {
  const PersonDetailItem({super.key});

  @override
  ConsumerState<PersonDetailItem> createState() => _PersonDetailItemState();
}

class _PersonDetailItemState extends ConsumerState<PersonDetailItem> {
  // Form state for manual trait creation
  String? _selectedTraitType;
  String? _selectedTag;
  String _traitDescription = '';
  final _formKey = GlobalKey<FormState>();
  final _descriptionController = TextEditingController();

  @override
  void dispose() {
    _descriptionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final person = ref.watch(currentPerson);
    final people = ref.watch(peopleProvider);
    final relations = ref.watch(relationshipsProvider);
    // Use firstWhere with orElse to handle missing nodes, and deduplicate if needed
    Node? myNode;
    final matchingNodes = relations.where((n) => n.id == person.id).toList();
    
    if (matchingNodes.isEmpty) {
      // No node exists, create an empty one for display purposes
      myNode = Node(id: person.id, relPairs: {});
    } else if (matchingNodes.length == 1) {
      // Perfect - exactly one node as expected
      myNode = matchingNodes.first;
    } else {
      // Multiple nodes found - this indicates the duplicate bug
      debugPrint("WARNING: Found ${matchingNodes.length} nodes for person ${person.id}. Using first one and suggesting cleanup.");
      myNode = matchingNodes.first;
      
      // Trigger cleanup of duplicates
      WidgetsBinding.instance.addPostFrameCallback((_) {
        ref.read(relationshipsProvider.notifier).deduplicateNodes();
      });
    }
    
  return SingleChildScrollView(
    child:Material(
      color: Colors.white,
      elevation: 6,
        child: GestureDetector(
          onTap: () {
            // ignore: avoid_print
            print(person.firstName);
          },
            child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              ...person.printDetail(people,myNode),
              // Add description section
              const SizedBox(height: 16),
              _buildDescriptionSection(context, ref, person),
              // Auto-generate descriptions if empty
              _autoGenerateDescriptions(ref, person),
            ],
          ),
         
        ),

    )
  );
  }

  Widget _buildDescriptionSection(BuildContext context, WidgetRef ref, person) {
    final physicalTraits = person.physicalTraits.map((t) => t.description).toList();
    final clothingTraits = person.clothingTraits.map((t) => t.description).toList();
    
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Character Description',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                IconButton(
                  icon: const Icon(Icons.refresh),
                  tooltip: 'Regenerate all descriptions',
                  onPressed: () => _regenerateAllDescriptions(ref, person),
                ),
              ],
            ),
            const SizedBox(height: 12),
            // Manual trait creation section
            _buildManualTraitCreator(context, ref, person),
            const SizedBox(height: 16),
            
            if (physicalTraits.isNotEmpty) ...[
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'Physical Traits',
                    style: Theme.of(context).textTheme.labelLarge?.copyWith(
                      color: Colors.blue[700],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.add_circle_outline, size: 20),
                    tooltip: 'Add more physical traits',
                    onPressed: () => _addMorePhysicalTraits(ref, person),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              ...physicalTraits.asMap().entries.map((entry) => 
                _buildTraitBullet(
                  context, 
                  entry.value, 
                  'physical', 
                  entry.key,
                  ref, 
                  person,
                ),
              ),
              const SizedBox(height: 12),
            ],
            if (clothingTraits.isNotEmpty) ...[
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'Clothing & Style',
                    style: Theme.of(context).textTheme.labelLarge?.copyWith(
                      color: Colors.green[700],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.add_circle_outline, size: 20),
                    tooltip: 'Add more clothing traits',
                    onPressed: () => _addMoreClothingTraits(ref, person),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              ...clothingTraits.asMap().entries.map((entry) => 
                _buildTraitBullet(
                  context, 
                  entry.value, 
                  'clothing', 
                  entry.key,
                  ref, 
                  person,
                ),
              ),
              const SizedBox(height: 12),
            ],
            if (physicalTraits.isEmpty && clothingTraits.isEmpty) ...[
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey.shade300),
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.grey.shade50,
                ),
                child: Text(
                  'Character descriptions will be generated automatically...',
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontStyle: FontStyle.italic,
                  ),
                  textAlign: TextAlign.center,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildDescriptionField(
    BuildContext context,
    String label,
    String? description,
    {VoidCallback? onReroll}
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              label,
              style: Theme.of(context).textTheme.labelLarge,
            ),
            if (description != null && onReroll != null)
              IconButton(
                icon: const Icon(Icons.casino, size: 16),
                tooltip: 'Reroll this description',
                onPressed: onReroll,
              ),
          ],
        ),
        const SizedBox(height: 4),
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            border: Border.all(color: Colors.grey.shade300),
            borderRadius: BorderRadius.circular(8),
            color: description == null ? Colors.grey.shade50 : Colors.white,
          ),
          child: Text(
            description ?? 'No description generated',
            style: TextStyle(
              fontSize: 14,
              color: description == null ? Colors.grey.shade600 : Colors.black87,
              fontStyle: description == null ? FontStyle.italic : FontStyle.normal,
            ),
          ),
        ),
      ],
    );
  }

  void _generateDescriptions(WidgetRef ref, person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty && clothingTemplates.isEmpty) {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No templates available. Please import templates first.'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }
      
      // Generate full description combining physical and clothing (for future use)
      // final fullDescription = descriptionService.generateFullDescription(
      //   person: person,
      //   physicalTemplates: physicalTemplates,
      //   clothingTemplates: clothingTemplates,
      //   allAncestries: allAncestryNames,
      //   maxTraits: 3,
      // );
      
      // Also generate individual descriptions
      final physicalDesc = physicalTemplates.isNotEmpty
          ? descriptionService.generatePhysicalDescription(
              person: person,
              templates: physicalTemplates,
              allAncestries: allAncestryNames,
            )
          : null;
          
      final clothingDesc = clothingTemplates.isNotEmpty
          ? descriptionService.generateClothingDescription(
              person: person,
              templates: clothingTemplates,
              allAncestries: allAncestryNames,
            )
          : null;
      
      // Update the person with new descriptions
      final peopleNotifier = ref.read(peopleProvider.notifier);
      final updatedPerson = person.copyWith(
        // Using trait-based system now
      );
      
      peopleNotifier.replace(person, updatedPerson);
      await peopleNotifier.commitChanges();
      
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text(
            'Generated descriptions using ${physicalTemplates.length} physical and ${clothingTemplates.length} clothing templates'
          ),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text('Error generating descriptions: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _regenerateDescriptions(WidgetRef ref, person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty && clothingTemplates.isEmpty) {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No templates available. Please import templates first.'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }
      
      // Regenerate both descriptions with new random selections
      final physicalDesc = physicalTemplates.isNotEmpty
          ? descriptionService.generatePhysicalDescription(
              person: person,
              templates: physicalTemplates,
              allAncestries: allAncestryNames,
            )
          : person.physicalDescription;
          
      final clothingDesc = clothingTemplates.isNotEmpty
          ? descriptionService.generateClothingDescription(
              person: person,
              templates: clothingTemplates,
              allAncestries: allAncestryNames,
            )
          : person.clothingDescription;
      
      // Update the person with regenerated descriptions
      final peopleNotifier = ref.read(peopleProvider.notifier);
      final updatedPerson = person.copyWith(
        physicalDescription: physicalDesc,
        clothingDescription: clothingDesc,
      );
      
      peopleNotifier.replace(person, updatedPerson);
      await peopleNotifier.commitChanges();
      
      ScaffoldMessenger.of(ref.context).showSnackBar(
        const SnackBar(
          content: Text('Descriptions regenerated with new random traits'),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text('Error regenerating descriptions: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _rerollPhysicalDescription(WidgetRef ref, person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty) {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No physical templates available. Please import templates first.'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }
      
      // Generate new physical description
      final newPhysicalDesc = descriptionService.generatePhysicalDescription(
        person: person,
        templates: physicalTemplates,
        allAncestries: allAncestryNames,
      );
      
      if (newPhysicalDesc != null) {
        // Update only the physical description
        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          physicalDescription: newPhysicalDesc,
        );
        
        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();
        
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('Physical description rerolled'),
            backgroundColor: Colors.green,
          ),
        );
      } else {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No suitable physical templates found for this character'),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text('Error rerolling physical description: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _rerollClothingDescription(WidgetRef ref, person) async {
    try {
      final descriptionService = DescriptionService();
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (clothingTemplates.isEmpty) {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No clothing templates available. Please import templates first.'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }
      
      // Generate new clothing description
      final newClothingDesc = descriptionService.generateClothingDescription(
        person: person,
        templates: clothingTemplates,
        allAncestries: allAncestryNames,
      );
      
      if (newClothingDesc != null) {
        // Update only the clothing description
        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          clothingDescription: newClothingDesc,
        );
        
        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();
        
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('Clothing description rerolled'),
            backgroundColor: Colors.green,
          ),
        );
      } else {
        ScaffoldMessenger.of(ref.context).showSnackBar(
          const SnackBar(
            content: Text('No suitable clothing templates found for this character'),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(ref.context).showSnackBar(
        SnackBar(
          content: Text('Error rerolling clothing description: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  // Helper method to parse descriptions into individual traits
  List<String> _parseDescriptionTraits(String? description) {
    if (description == null || description.isEmpty) {
      return [];
    }
    
    // Split by sentence-ending punctuation and clean up
    return description
        .split(RegExp(r'[.!?]+'))
        .map((trait) => trait.trim())
        .where((trait) => trait.isNotEmpty)
        .toList();
  }

  // Build a single trait bullet point with reroll button
  Widget _buildTraitBullet(
    BuildContext context,
    String trait,
    String type, // 'physical' or 'clothing'
    int index,
    WidgetRef ref,
    dynamic person,
  ) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            margin: const EdgeInsets.only(top: 8, right: 8),
            width: 4,
            height: 4,
            decoration: BoxDecoration(
              color: type == 'physical' ? Colors.blue[700] : Colors.green[700],
              shape: BoxShape.circle,
            ),
          ),
          Expanded(
            child: Text(
              trait,
              style: const TextStyle(fontSize: 14, height: 1.4),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.casino, size: 16),
            tooltip: 'Reroll this trait',
            onPressed: () => _rerollSpecificTrait(ref, person, type, index),
            constraints: const BoxConstraints(
              minWidth: 24,
              minHeight: 24,
            ),
            padding: const EdgeInsets.all(4),
          ),
        ],
      ),
    );
  }

  // Auto-generate descriptions if empty
  Widget _autoGenerateDescriptions(WidgetRef ref, dynamic person) {
    // Auto-generate if both descriptions are empty or null
    if (person.physicalTraits.isEmpty && person.clothingTraits.isEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _generateInitialDescriptions(ref, person);
      });
    }
    return const SizedBox.shrink();
  }

  // Reroll a specific trait by index and type
  void _rerollSpecificTrait(WidgetRef ref, dynamic person, String type, int traitIndex) async {
    try {
      final descriptionService = DescriptionService();
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      String? newDescription;
      String currentDescription = '';
      
      if (type == 'physical') {
        final physicalTemplates = ref.read(physicalTemplatesProvider);
        if (physicalTemplates.isEmpty) {
          _showTemplateError(ref, 'No physical templates available');
          return;
        }
        
        currentDescription = person.physicalTraits.isNotEmpty ? person.physicalTraits.first.description : '';
        newDescription = descriptionService.generatePhysicalDescription(
          person: person,
          templates: physicalTemplates,
          allAncestries: allAncestryNames,
        );
      } else if (type == 'clothing') {
        final clothingTemplates = ref.read(clothingTemplatesProvider);
        if (clothingTemplates.isEmpty) {
          _showTemplateError(ref, 'No clothing templates available');
          return;
        }
        
        currentDescription = person.clothingTraits.isNotEmpty ? person.clothingTraits.first.description : '';
        newDescription = descriptionService.generateClothingDescription(
          person: person,
          templates: clothingTemplates,
          allAncestries: allAncestryNames,
        );
      }
      
      if (newDescription != null && newDescription != currentDescription) {
        // Parse the new description and replace just the specific trait
        final newTraits = _parseDescriptionTraits(newDescription);
        final currentTraits = _parseDescriptionTraits(currentDescription);
        
        if (newTraits.isNotEmpty && traitIndex < currentTraits.length) {
          // Replace the specific trait with a random new one
          final updatedTraits = List<String>.from(currentTraits);
          if (newTraits.isNotEmpty) {
            updatedTraits[traitIndex] = newTraits.first;
          }
          
          final updatedDescription = updatedTraits.join('. ') + '.';
          
          // Update the person
          final peopleNotifier = ref.read(peopleProvider.notifier);
          final updatedPerson = type == 'physical'
              ? person // TODO: Update to use traits
              : person; // TODO: Update to use traits
          
          peopleNotifier.replace(person, updatedPerson);
          await peopleNotifier.commitChanges();
        }
      }
    } catch (e) {
      _showError(ref, 'Error rerolling trait: $e');
    }
  }

  // Add more traits from unused tags
  void _addMoreTraits(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      // Find used tags
      final usedTags = <String>{};
      final currentPhysical = person.physicalTraits.map((t) => t.description).toList();
      final currentClothing = person.clothingTraits.map((t) => t.description).toList();
      
      // Generate new traits from unused templates
      String? newPhysicalTrait;
      String? newClothingTrait;
      
      if (physicalTemplates.isNotEmpty) {
        newPhysicalTrait = descriptionService.generatePhysicalDescription(
          person: person,
          templates: physicalTemplates,
          allAncestries: allAncestryNames,
          excludeTags: usedTags.toList(),
        );
      }
      
      if (clothingTemplates.isNotEmpty) {
        newClothingTrait = descriptionService.generateClothingDescription(
          person: person,
          templates: clothingTemplates,
          allAncestries: allAncestryNames,
          excludeTags: usedTags.toList(),
        );
      }
      
      // Add new traits to existing descriptions
      final peopleNotifier = ref.read(peopleProvider.notifier);
      final updatedPhysical = newPhysicalTrait != null
          ? (currentPhysical + _parseDescriptionTraits(newPhysicalTrait)).join('. ') + '.'
          : person.physicalDescription;
      final updatedClothing = newClothingTrait != null
          ? (currentClothing + _parseDescriptionTraits(newClothingTrait)).join('. ') + '.'
          : person.clothingDescription;
      
      final updatedPerson = person.copyWith(
        physicalDescription: updatedPhysical,
        clothingDescription: updatedClothing,
      );
      
      peopleNotifier.replace(person, updatedPerson);
      await peopleNotifier.commitChanges();
      
      _showSuccess(ref, 'Added new traits to description');
    } catch (e) {
      _showError(ref, 'Error adding more traits: $e');
    }
  }

  // Regenerate all descriptions
  void _regenerateAllDescriptions(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty && clothingTemplates.isEmpty) {
        _showTemplateError(ref, 'No templates available');
        return;
      }
      
      final newPhysical = physicalTemplates.isNotEmpty
          ? descriptionService.generatePhysicalDescription(
              person: person,
              templates: physicalTemplates,
              allAncestries: allAncestryNames,
            )
          : person.physicalDescription;
          
      final newClothing = clothingTemplates.isNotEmpty
          ? descriptionService.generateClothingDescription(
              person: person,
              templates: clothingTemplates,
              allAncestries: allAncestryNames,
            )
          : person.clothingDescription;
      
      final peopleNotifier = ref.read(peopleProvider.notifier);
      final updatedPerson = person.copyWith(
        physicalDescription: newPhysical,
        clothingDescription: newClothing,
      );
      
      peopleNotifier.replace(person, updatedPerson);
      await peopleNotifier.commitChanges();
      
      _showSuccess(ref, 'All descriptions regenerated');
    } catch (e) {
      _showError(ref, 'Error regenerating descriptions: $e');
    }
  }

  // Generate initial descriptions for new characters
  void _generateInitialDescriptions(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();
      
      if (physicalTemplates.isEmpty && clothingTemplates.isEmpty) {
        return; // No templates available, skip auto-generation
      }
      
      String? physicalDesc;
      String? clothingDesc;
      
      if (physicalTemplates.isNotEmpty && person.physicalTraits.isEmpty) {
        physicalDesc = descriptionService.generatePhysicalDescription(
          person: person,
          templates: physicalTemplates,
          allAncestries: allAncestryNames,
        );
      }
      
      if (clothingTemplates.isNotEmpty && person.clothingTraits.isEmpty) {
        clothingDesc = descriptionService.generateClothingDescription(
          person: person,
          templates: clothingTemplates,
          allAncestries: allAncestryNames,
        );
      }
      
      if (physicalDesc != null || clothingDesc != null) {
        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          // TODO: Update to use trait-based system
        );
        
        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();
      }
    } catch (e) {
      // Silent fail for auto-generation
      debugPrint('Auto-generation failed: $e');
    }
  }

  // Helper methods for showing messages
  void _showError(WidgetRef ref, String message) {
    ScaffoldMessenger.of(ref.context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
      ),
    );
  }

  void _showTemplateError(WidgetRef ref, String message) {
    ScaffoldMessenger.of(ref.context).showSnackBar(
      SnackBar(
        content: Text('$message. Please import templates first.'),
        backgroundColor: Colors.orange,
      ),
    );
  }

  void _showSuccess(WidgetRef ref, String message) {
    ScaffoldMessenger.of(ref.context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green,
      ),
    );
  }
  void _addMorePhysicalTraits(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final physicalTemplates = ref.read(physicalTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();

      if (physicalTemplates.isEmpty) {
        _showTemplateError(ref, 'No physical templates available');
        return;
      }

      final newPhysicalTrait = descriptionService.generatePhysicalDescription(
        person: person,
        templates: physicalTemplates,
        allAncestries: allAncestryNames,
      );

      if (newPhysicalTrait != null) {
        final currentTraits = _parseDescriptionTraits(person.physicalDescription);
        final newTraits = _parseDescriptionTraits(newPhysicalTrait);
        final combinedTraits = [...currentTraits, ...newTraits];
        final updatedDescription = combinedTraits.join('. ') + '.';

        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          physicalDescription: updatedDescription,
        );

        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();

        _showSuccess(ref, 'Added new physical trait');
      } else {
        _showError(ref, 'No new physical traits available');
      }
    } catch (e) {
      _showError(ref, 'Error adding physical trait: $e');
    }
  }

  // Add more clothing traits from unused tags
  void _addMoreClothingTraits(WidgetRef ref, dynamic person) async {
    try {
      final descriptionService = DescriptionService();
      final clothingTemplates = ref.read(clothingTemplatesProvider);
      final ancestries = ref.read(ancestriesProvider);
      final allAncestryNames = ancestries.map((a) => a.name).toList();

      if (clothingTemplates.isEmpty) {
        _showTemplateError(ref, 'No clothing templates available');
        return;
      }

      final newClothingTrait = descriptionService.generateClothingDescription(
        person: person,
        templates: clothingTemplates,
        allAncestries: allAncestryNames,
      );

      if (newClothingTrait != null) {
        final currentTraits = _parseDescriptionTraits(person.clothingDescription);
        final newTraits = _parseDescriptionTraits(newClothingTrait);
        final combinedTraits = [...currentTraits, ...newTraits];
        final updatedDescription = combinedTraits.join('. ') + '.';

        final peopleNotifier = ref.read(peopleProvider.notifier);
        final updatedPerson = person.copyWith(
          clothingDescription: updatedDescription,
        );

        peopleNotifier.replace(person, updatedPerson);
        await peopleNotifier.commitChanges();

        _showSuccess(ref, 'Added new clothing trait');
      } else {
        _showError(ref, 'No new clothing traits available');
      }
    } catch (e) {
      _showError(ref, 'Error adding clothing trait: $e');
    }
  }

  Widget _buildManualTraitCreator(BuildContext context, WidgetRef ref, dynamic person) {
    final physicalTemplates = ref.watch(physicalTemplatesProvider);
    final clothingTemplates = ref.watch(clothingTemplatesProvider);
    
    // Get all available tags
    final physicalTags = physicalTemplates.map((t) => t.tag).toSet().toList()..sort();
    final clothingTags = clothingTemplates.map((t) => t.tag).toSet().toList()..sort();
    
    // Get already used tags to show availability
    final usedPhysicalTags = person.physicalTraits.map((t) => t.tag).toSet();
    final usedClothingTags = person.clothingTraits.map((t) => t.tag).toSet();
    
    // Get available tags based on selected type
    List<String> availableTags = [];
    if (_selectedTraitType == 'physical') {
      availableTags = physicalTags;
    } else if (_selectedTraitType == 'clothing') {
      availableTags = clothingTags;
    }
    
    return Form(
      key: _formKey,
      child: Card(
        color: Colors.grey[50],
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Create Custom Trait',
                style: Theme.of(context).textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 12),
              
              Row(
                children: [
                  // Trait type selection
                  Expanded(
                    flex: 2,
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text('Type:', style: TextStyle(fontWeight: FontWeight.w500)),
                        const SizedBox(height: 4),
                        DropdownButtonFormField<String>(
                          decoration: const InputDecoration(
                            border: OutlineInputBorder(),
                            contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                          ),
                          hint: const Text('Select type'),
                          value: _selectedTraitType,
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please select a type';
                            }
                            return null;
                          },
                          items: [
                            const DropdownMenuItem(value: 'physical', child: Text('Physical')),
                            const DropdownMenuItem(value: 'clothing', child: Text('Clothing')),
                          ],
                          onChanged: (value) {
                            setState(() {
                              _selectedTraitType = value;
                              _selectedTag = null; // Reset tag when type changes
                            });
                          },
                        ),
                      ],
                    ),
                  ),
                  
                  const SizedBox(width: 12),
                  
                  // Tag selection
                  Expanded(
                    flex: 3,
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text('Tag:', style: TextStyle(fontWeight: FontWeight.w500)),
                        const SizedBox(height: 4),
                        DropdownButtonFormField<String>(
                          decoration: const InputDecoration(
                            border: OutlineInputBorder(),
                            contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                          ),
                          hint: const Text('Select tag'),
                          value: _selectedTag,
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please select a tag';
                            }
                            return null;
                          },
                          items: availableTags.map((tag) {
                            final isUsed = _selectedTraitType == 'physical'
                                ? usedPhysicalTags.contains(tag)
                                : usedClothingTags.contains(tag);
                            
                            return DropdownMenuItem(
                              value: tag,
                              child: Row(
                                children: [
                                  Text(tag),
                                  if (isUsed) ...[
                                    const SizedBox(width: 8),
                                    Icon(Icons.warning, size: 16, color: Colors.orange),
                                    const SizedBox(width: 4),
                                    Text('(exists)', style: TextStyle(fontSize: 10, color: Colors.orange)),
                                  ],
                                ],
                              ),
                            );
                          }).toList(),
                          onChanged: (value) {
                            setState(() {
                              _selectedTag = value;
                            });
                          },
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: 12),
              
              // Description input
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('Description:', style: TextStyle(fontWeight: FontWeight.w500)),
                  const SizedBox(height: 4),
                  TextFormField(
                    controller: _descriptionController,
                    decoration: const InputDecoration(
                      border: OutlineInputBorder(),
                      hintText: 'Enter trait description...',
                      contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    ),
                    maxLines: 2,
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return 'Please enter a description';
                      }
                      return null;
                    },
                    onChanged: (value) {
                      _traitDescription = value;
                    },
                  ),
                ],
              ),
              
              const SizedBox(height: 12),
              
              // Add button
              Align(
                alignment: Alignment.centerRight,
                child: ElevatedButton.icon(
                  onPressed: () {
                    _addCustomTrait(ref, person);
                  },
                  icon: const Icon(Icons.add, size: 18),
                  label: const Text('Add Trait'),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _addCustomTrait(WidgetRef ref, dynamic person) async {
    // Validate the form
    if (!_formKey.currentState!.validate()) {
      return;
    }
    
    if (_selectedTraitType == null || _selectedTag == null || _traitDescription.trim().isEmpty) {
      _showError(ref, 'Please fill in all fields');
      return;
    }
    
    try {
      // Check if this tag already exists for this person
      final existingTraits = _selectedTraitType == 'physical'
          ? person.physicalTraits
          : person.clothingTraits;
      
      final tagExists = existingTraits.any((trait) => trait.tag == _selectedTag);
      
      if (tagExists) {
        // Show confirmation dialog
        final shouldReplace = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('Tag Already Exists'),
            content: Text(
              'This character already has a ${_selectedTraitType} trait for "${_selectedTag}". '
              'Do you want to replace it with the new description?'
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: const Text('Cancel'),
              ),
              TextButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: const Text('Replace'),
              ),
            ],
          ),
        );
        
        if (shouldReplace != true) return;
      }
      
      // Create the new trait
      final newTrait = CharacterTrait.generate(
        tag: _selectedTag!,
        description: _traitDescription.trim(),
        type: _selectedTraitType!,
      );
      
      // Update the person's traits
      final peopleNotifier = ref.read(peopleProvider.notifier);
      
      List<CharacterTrait> updatedTraits;
      Person updatedPerson;
      
      if (_selectedTraitType == 'physical') {
        if (tagExists) {
          // Replace existing trait with same tag
          updatedTraits = person.physicalTraits
              .where((trait) => trait.tag != _selectedTag)
              .toList()
            ..add(newTrait);
        } else {
          // Add new trait
          updatedTraits = [...person.physicalTraits, newTrait];
        }
        updatedPerson = person.copyWith(physicalTraits: updatedTraits);
      } else {
        if (tagExists) {
          // Replace existing trait with same tag
          updatedTraits = person.clothingTraits
              .where((trait) => trait.tag != _selectedTag)
              .toList()
            ..add(newTrait);
        } else {
          // Add new trait
          updatedTraits = [...person.clothingTraits, newTrait];
        }
        updatedPerson = person.copyWith(clothingTraits: updatedTraits);
      }
      
      // Save the changes
      peopleNotifier.replace(person, updatedPerson);
      await peopleNotifier.commitChanges();
      
      // Clear the form
      setState(() {
        _selectedTraitType = null;
        _selectedTag = null;
        _traitDescription = '';
        _descriptionController.clear();
      });
      
      // Show success message
      final action = tagExists ? 'replaced' : 'added';
      _showSuccess(ref, 'Custom ${_selectedTraitType} trait $action successfully!');
      
    } catch (e) {
      _showError(ref, 'Error creating trait: $e');
    }
  }
}

