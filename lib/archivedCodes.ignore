
// class PersonEditItem extends HookConsumerWidget {
//   const PersonEditItem({super.key});

//   @override
//   Widget build(BuildContext context, WidgetRef ref) {
//     final me = ref.watch(currentPerson);
//     final peopleNotif=ref.watch(ref.read(townProvider).peopleListProvider.notifier);
//     final peopleSearchNotif=ref.watch(ref.read(townProvider).peopleSearch.notifier);
    
//     final firstNameFocusNode = useFocusNode();
//     final firstNameIsFocused = useIsFocused(firstNameFocusNode);

//     final surnameFocusNode = useFocusNode();
//     final surnameIsFocused = useIsFocused(surnameFocusNode);

//     final ancestryFocusNode = useFocusNode();
//     final ancestryIsFocused = useIsFocused(ancestryFocusNode);

//     final pronounsFocusNode = useFocusNode();
//     final pronounsIsFocused = useIsFocused(pronounsFocusNode);

//     final ageFocusNode = useFocusNode();
//     final ageIsFocused = useIsFocused(ageFocusNode);

//     final quirk1FocusNode = useFocusNode();
//     final quirk1IsFocused = useIsFocused(quirk1FocusNode);

//     final quirk2FocusNode = useFocusNode();
//     final quirk2IsFocused = useIsFocused(quirk2FocusNode);

//     final resonantArgumentFocusNode = useFocusNode();
//     final resonantArgumentIsFocused = useIsFocused(resonantArgumentFocusNode);

//     final factionFocusNode = useFocusNode();
//     final factionIsFocused = useIsFocused(factionFocusNode);

//     final textEditingController = useTextEditingController();
//     final textFieldFocusNode = useFocusNode();
//   return Material(
//       color: Colors.white,
//       elevation: 6,
//       child: Column(
//         children: [
//       Focus(
//         focusNode: firstNameFocusNode,
//         onFocusChange: (focused) {
//           if (focused) {
//             textEditingController.text = me.firstName;
//           } else {
//             // Commit changes only when the textfield is unfocused, for performance
//             peopleSearchNotif.edit(me.firstName,textEditingController.text,me.id);
//             peopleNotif.edit(replaceID: me.id, newFirstName: textEditingController.text);
            
            
//           }
//         },
//         child: ListTile(
//           onTap: () {
//             firstNameFocusNode.requestFocus();
//             textFieldFocusNode.requestFocus();
//           },
//           title: firstNameIsFocused
//               ? TextField(
//                   autofocus: true,
//                   focusNode: textFieldFocusNode,
//                   controller: textEditingController,
//                 )
//               : Text("First Name: ${me.firstName}"),
//         ),
//       ),
//      Focus(
//         focusNode: surnameFocusNode,
//         onFocusChange: (focused) {
//           if (focused) {
//             textEditingController.text = me.surname;
//           } else {
//             // Commit changes only when the textfield is unfocused, for performance
//             peopleSearchNotif.edit(me.surname,textEditingController.text,me.id);
//             peopleNotif.edit(replaceID: me.id, newSurname: textEditingController.text);
//           }
//         },
//         child: ListTile(
//           onTap: () {
//             surnameFocusNode.requestFocus();
//             textFieldFocusNode.requestFocus();
//           },
//           title: surnameIsFocused
//               ? TextField(
//                   autofocus: true,
//                   focusNode: textFieldFocusNode,
//                   controller: textEditingController,
//                 )
//               : Text("Surname: ${me.surname}"),
//         ),
//       ),
//       Focus(
//         focusNode: ancestryFocusNode,
//         onFocusChange: (focused) {
//           if (focused) {
//             textEditingController.text = me.ancestry;
//           } else {
//             // Commit changes only when the textfield is unfocused, for performance
//             peopleNotif.edit(replaceID: me.id, newAncestry: textEditingController.text);
//           }
//         },
//         child: ListTile(
//           onTap: () {
//             ancestryFocusNode.requestFocus();
//             textFieldFocusNode.requestFocus();
//           },
//           title: ancestryIsFocused
//               ? TextField(
//                   autofocus: true,
//                   focusNode: textFieldFocusNode,
//                   controller: textEditingController,
//                 )
//               : Text("Ancestry: ${me.ancestry}"),
//         ),
//       ),
//        Focus(
//         focusNode: pronounsFocusNode,
//         onFocusChange: (focused) {
//           if (focused) {
//             textEditingController.text = me.pronouns as String;
//           } else {
//             // Commit changes only when the textfield is unfocused, for performance
//             peopleNotif.edit(replaceID: me.id, newPronouns: string2Enum(textEditingController.text));
//           }
//         },
//         child: ListTile(
//           onTap: () {
//             pronounsFocusNode.requestFocus();
//             textFieldFocusNode.requestFocus();
//           },
//           title: pronounsIsFocused
//               ? TextField(
//                   autofocus: true,
//                   focusNode: textFieldFocusNode,
//                   controller: textEditingController,
//                 )
//               : Text("Pronouns: ${me.pronouns}"),
//         ),
//       ),
//        Focus(
//         focusNode: ageFocusNode,
//         onFocusChange: (focused) {
//           if (focused) {
//             textEditingController.text = me.age as String;
//           } else {
//             // Commit changes only when the textfield is unfocused, for performance
//             peopleNotif.edit(replaceID: me.id, newAge: string2Enum(textEditingController.text));
//           }
//         },
//         child: ListTile(
//           onTap: () {
//             ageFocusNode.requestFocus();
//             textFieldFocusNode.requestFocus();
//           },
//           title: ageIsFocused
//               ? TextField(
//                   autofocus: true,
//                   focusNode: textFieldFocusNode,
//                   controller: textEditingController,
//                 )
//               : Text("Age: ${me.age}"),
//         ),
//       ),
//        Focus(
//         focusNode: quirk1FocusNode,
//         onFocusChange: (focused) {
//           if (focused) {
//             textEditingController.text = me.quirk1;
//           } else {
//             // Commit changes only when the textfield is unfocused, for performance
//             peopleSearchNotif.edit(me.quirk1,textEditingController.text,me.id);
//             peopleNotif.edit(replaceID: me.id, newQuirk1: textEditingController.text);
//           }
//         },
//         child: ListTile(
//           onTap: () {
//             quirk1FocusNode.requestFocus();
//             textFieldFocusNode.requestFocus();
//           },
//           title: quirk1IsFocused
//               ? TextField(
//                   autofocus: true,
//                   focusNode: textFieldFocusNode,
//                   controller: textEditingController,
//                 )
//               : Text("Quirk 1: ${me.quirk1}"),
//         ),
//       ),
//        Focus(
//         focusNode: quirk2FocusNode,
//         onFocusChange: (focused) {
//           if (focused) {
//             textEditingController.text = me.quirk2;
//           } else {
//             // Commit changes only when the textfield is unfocused, for performance
//             peopleSearchNotif.edit(me.quirk2,textEditingController.text,me.id);
//             peopleNotif.edit(replaceID: me.id, newQuirk2: textEditingController.text);
//           }
//         },
//         child: ListTile(
//           onTap: () {
//             quirk2FocusNode.requestFocus();
//             textFieldFocusNode.requestFocus();
//           },
//           title: quirk2IsFocused
//               ? TextField(
//                   autofocus: true,
//                   focusNode: textFieldFocusNode,
//                   controller: textEditingController,
//                 )
//               : Text("Quirk 2: ${me.quirk2}"),
//         ),
//       ),
//        Focus(
//         focusNode: resonantArgumentFocusNode,
//         onFocusChange: (focused) {
//           if (focused) {
//             textEditingController.text = me.resonantArgument;
//           } else {
//             // Commit changes only when the textfield is unfocused, for performance
//             peopleSearchNotif.edit(me.resonantArgument,textEditingController.text,me.id);
//             peopleNotif.edit(replaceID: me.id, newResonantArgument: textEditingController.text);

//           }
//         },
//         child: ListTile(
//           onTap: () {
//             resonantArgumentFocusNode.requestFocus();
//             textFieldFocusNode.requestFocus();
//           },
//           title: resonantArgumentIsFocused
//               ? TextField(
//                   autofocus: true,
//                   focusNode: textFieldFocusNode,
//                   controller: textEditingController,
//                 )
//               : Text("Resonant Argument: ${me.resonantArgument}"),
//         ),
//       ),
//        Focus(
//         focusNode: factionFocusNode,
//         onFocusChange: (focused) {
//           if (focused) {
//             textEditingController.text = me.faction;
//           } else {
//             // Commit changes only when the textfield is unfocused, for performance
//             peopleNotif.edit(replaceID: me.id, newFaction: textEditingController.text);
//           }
//         },
//         child: ListTile(
//           onTap: () {
//             factionFocusNode.requestFocus();
//             textFieldFocusNode.requestFocus();
//           },
//           title: factionIsFocused
//               ? TextField(
//                   autofocus: true,
//                   focusNode: textFieldFocusNode,
//                   controller: textEditingController,
//                 )
//               : Text("Faction: ${me.faction}"),
//         ),
//       ),
//         ]
      
//   )
//   );
//   }
// }

  // factory PeopleList.fromJson(String json)
  // {
  //   Map<String,dynamic> data = jsonDecode(json);
  //   return PeopleList(
  //     ancestries: data["initAncestry"].map((a)=>Ancestry.fromJson((jsonEncode(a)))).toList(),
  //     givenNames: data["initGivenNames"].map((g)=>GivenName.fromJson(jsonEncode(g))).toList(),
  //     surnames: data["initSurnames"].map((s)=>Surname.fromJson((jsonEncode(s)))).toList(),
  //     resonantArguments: data["initResonantArguments"],
  //     quirks: data["initQuirks"], 
  //      );
  // }

  // Future<void> bulkAdd(List<Person> myPeople) async{
  //   Map<String,String> addMe = {for(var person in myPeople) person.id:jsonEncode(person.toJson())};
  //   await peopleBox.putAll(addMe);
  //   state = peopleBox.values.map((e)=>Person.fromJson(e)).cast<Person>().toList();
  // }


  
  // Future<bool> randomBreakUp(String myAncestry) async {
  //     final Ancestry a = ancestries.singleWhere((s)=>s.name==myAncestry);
  //     return Future.value(a.breakup());
  //   }
  
  // Future<List<AdoptionType>> randomChildrenTypes(String myAncestry) async {
  //     final myDemo = ancestries.singleWhere((c)=>myAncestry==c.name);
  //     List<AdoptionType> myList=[];
  //     for(int i=0; i<myDemo.randomNumChildren(); i++)
  //     {
  //       myList.add(myDemo.randomAdoptionType());
  //     }
  //     return myList;
  //   }
  // Future<AdoptionType> randomAdoption(String myAncestry) async{
  //     return ancestries.singleWhere((c)=>c.name==myAncestry).randomAdoptionType(); 
  //   }
  
  
  // Future<void> addLocationRoleToPerson({required String myID, required LocationRole myRole}) async
  // {
  //   Person me = state.singleWhere((p)=> p.id==myID);
  //   List<LocationRole> myRoles=me.myRoles;
  //   myRoles.add(myRole);
  //   await edit(replaceID: myID, newRoles: myRoles);
  // }
  // Future<String> findASpouse(String myID,List<String> ancestrySet) async{
  //   Person me=state.singleWhere((p)=> p.id == myID);

  //   Set<PronounType>? myPreferredPartnersPronouns;
  //   switch(me.orientation)
  //   {
  //     case OrientationType.straight: myPreferredPartnersPronouns=straightCandidatePronouns[me.pronouns];break;
  //     case OrientationType.queer: myPreferredPartnersPronouns=queerCandidatePronouns[me.pronouns];break;
  //     default: myPreferredPartnersPronouns={PronounType.any};
  //   }

  //   // final Set<PronounType> myPPP= myPreferredPartnersPronouns ?? {PronounType.any};
  //   final myPartnerAges = allowedToPartner[me.age];
    
  //   final candidates = state.where(
  //     (c) =>  (
  //             (me.myPreferredPartnersPronouns.contains(c.pronouns)))
  //             &&
  //             (c.myPreferredPartnersPronouns.contains(me.pronouns))
  //             &&
  //             (myPartnerAges!.contains(c.age))
  //             &&
  //             (!(me.exIDs.contains(c.id)))
  //             &&
  //             (c.id != me.id)
  //             // &&
  //             //   // (
  //             //   //   ((c.partnerID.isEmpty) && (c.poly==poly2String[PolyType.notPoly])
  //             //   //    )||(
  //             //   //    c.poly==poly2String[PolyType.poly]
  //             //   //   )
  //             //   // )
  //             &&
  //             (ancestrySet.contains(c.ancestry))
  //             &&
  //             (c.poly==me.poly)
  //             &&
  //             ((me.countPartner()+c.countPartner()) < min(me.maxSpouse,c.maxSpouse))

              
  //   ).toList();

  //   if(candidates.isEmpty)
  //   { return "Empty";}
  //   else
  //   {
  //     final rando=random.nextInt(candidates.length);
  //     if({AgeType.young,AgeType.quiteYoung}.contains(candidates[rando].age))
  //     {
  //       throw("ruhroh");
  //     }
  //     return (candidates[rando]).id;
  //   }    
  // }

  // Future<String> makePartners({required String myID, required String yourID,}) async
  // {
  //   Person me=state.singleWhere((p)=> p.id == myID);
  //   int youIndex=state.indexWhere((p)=>p.id==yourID);
  //   Person you;
  //   bool youFlag=true;
  //   if(youIndex!=-1)
  //   {
  //     you=state[youIndex];
  //     youFlag=you.canMarry();
  //   }
  //   if(me.canMarry()&&youFlag){
  //     Set<PronounType>? myPreferredPartnersPronouns;
  //     switch(me.orientation)
  //     {
  //       case OrientationType.straight: myPreferredPartnersPronouns=straightCandidatePronouns[me.pronouns];break;
  //       case OrientationType.queer: myPreferredPartnersPronouns=queerCandidatePronouns[me.pronouns];break;
  //       default: myPreferredPartnersPronouns={PronounType.any};
  //     }

  //     final Set<PronounType> myPPP= myPreferredPartnersPronouns ?? {PronounType.any};
  //     if(allowedToPartner[me.age]!.isNotEmpty)
  //     {
  //       if(yourID=="Empty"){
  //       yourID=_uuid.v4();
  //       await createRandomPerson(
  //           newPoly: me.poly,
  //           newOrientation: me.orientation,
  //           newAge: me.age,
  //           newFaction: me.faction,
  //           newSurname: me.surname,
  //           newPronouns: myPPP.elementAt(random.nextInt(myPPP.length)),
  //           newID: yourID,
  //           );
  //       }
  //       Person you= state.singleWhere((p)=> p.id == yourID);

  //       int x = me.countPartner();
  //       int y = you.countPartner();
  //       bool z = (x+y)<min(me.maxSpouse,you.maxSpouse);
  //       print ("Debuggin'");
  //       List<Relationship> myR=me.relationships;
  //       List<Relationship> youR=you.relationships;
  //       myR.add(Relationship(myID: yourID, myType: RelationshipType.partner));
  //       youR.add(Relationship(myID: myID, myType: RelationshipType.partner));
        
      
  //       List<String?> mePartners=me.partnerID;
  //       List<String?> youPartners=you.partnerID;
  //       List<String> ourPartners=[myID,yourID];
  //       for(int i=0; i<youPartners.length; i++)
  //       {
  //         ourPartners.add(youPartners[i]!);
  //       }
  //       for(int i=0; i<mePartners.length; i++)
  //       {
  //         ourPartners.add(mePartners[i]!);

  //       }

  //       final ourPartnersSet=ourPartners.toSet();
  //       List<String> thePartners=[];
  //       String theID;
      
  //       for(int i=0; i<ourPartnersSet.length;i++)
  //       {
  //         theID = ourPartners[i];
  //         thePartners=ourPartners.where((p)=>p!=theID).toList();
  //         Person thePerson=state.singleWhere((p)=>p.id==theID);
  //         List<Relationship> theR = thePerson.relationships;
  //         theR.addAll(thePartners.map((p)=>Relationship(myID: p, myType: RelationshipType.partner)));
  //         theR=theR.toSet().toList();

  //         await edit(replaceID: theID,newPartnerID: thePartners,newRelationships: theR);
  //       }
  //   }
  // }
  // return yourID;
  // }
  // Future<void> makeExes({required String myID,
  //             }) async
  // {
  //   Person me=state.singleWhere((p)=> p.id == myID);
    
  //   var mePartners=me.partnerID;
  //   var meExes=me.exIDs;
    
  //   Person you;
  //   List<String?> youPartners;
  //   List<String?> youExes;
    
  //   List<Relationship> meR=me.relationships;
  //   for(int i=0; i< mePartners.length; i++)
  //   {
  //     you=state.singleWhere((y)=>y.id==mePartners[i]);
  //     youPartners=you.partnerID.where((p)=>p !=myID).toList();
  //     youExes=you.exIDs;
  //     youExes.add(myID);
  //     await edit(replaceID: you.id,newPartnerID: youPartners, newExID: youExes.whereType<String>().toList());
  //     meExes.add(you.id);

  //     List<Relationship> youR=you.relationships;
  //     youR.add(Relationship(myID: myID, myType: RelationshipType.ex));
  //     youR=youR.where((r)=>!(r.myType==RelationshipType.partner && r.myID==myID)).toList();
  //     await edit(replaceID: you.id,newRelationships: youR);
  //     meR.add(Relationship(myID: you.id, myType: RelationshipType.ex));
  //     meR=meR.where((r)=>!(r.myType==RelationshipType.partner && r.myID==you.id)).toList();
  //   }
  //   await edit(replaceID: myID,newRelationships: meR);
  
  //   await edit(replaceID: myID,newPartnerID: mePartners,newExID: meExes.whereType<String>().toList());

  // }
  // Future<void> makeChildrenParentRelationship({required String parent1, required String parent2, required String child}) async  {

  //   Person p1=state.singleWhere((p)=> p.id == parent1);
    
  //   Person c=state.singleWhere((p) => p.id == child);

  //   var p1Children=p1.childrenID;
    
  //   var cParents=c.parents;
  //   p1Children.add(child);
  //   List<Relationship>p1R = p1.relationships;
  //   p1R.add(Relationship(myID: child, myType: RelationshipType.parent));
  //   List<Relationship> cR=c.relationships;

  //   for(int i =0; i<p1R.length; i++)
  //   {
  //     if(p1R[i].myID==c.id){cR.add(Relationship(myID: parent1, myType: RelationshipType.parent));}
  //     else 
  //       {switch(p1R[i].myType)
  //       {
  //         case RelationshipType.partner:
  //         Person partner=state.singleWhere((p)=>p.id==p1R[i].myID);
  //           List<Relationship> partnerRel=partner.relationships;
  //           partnerRel.add(Relationship(myID: c.id, myType: RelationshipType.child));
  //           cR.add(Relationship(myID: partner.id, myType: RelationshipType.parent));
  //           await edit(replaceID: partner.id,newRelationships: partnerRel.toSet().toList());

  //           break;
  //         case RelationshipType.child:
  //         Person sib = state.singleWhere((p)=>p.id==p1R[i].myID);
  //           List<Relationship> sibR=sib.relationships;
  //           sibR.add(Relationship(myID: c.id, myType: RelationshipType.sibling));
  //           cR.add(Relationship(myID: sib.id, myType: RelationshipType.sibling));
  //           await edit(replaceID: sib.id,newRelationships: sibR.toSet().toList());
  //           break;
  //         default: break;
  //       }}
  //   }
    
  //   cParents.add(parent1);
  //   await edit(replaceID: parent1, newChildrenID: p1Children);
    
  //   if(parent2!="Empty")
  //   {
  //     Person p2= state.singleWhere((p)=> p.id == parent2);
      
  //     var p2Children=p2.childrenID;
  //     p2Children.add(child);
  //     await edit(replaceID: parent2,newChildrenID: p2Children);
  //     cParents.add(parent2);
  //     List<Relationship>p2R = p2.relationships;
  //     p2R.add(Relationship(myID: child, myType: RelationshipType.parent));
  //     List<Relationship> cR=c.relationships;

  //   for(int i =0; i<p2R.length; i++)
  //   {
  //     if(p2R[i].myID==c.id){cR.add(Relationship(myID: p2.id, myType: RelationshipType.parent));}
  //     else 
  //       {switch(p2R[i].myType)
  //       {
  //         case RelationshipType.partner:
  //         Person partner=state.singleWhere((p)=>p.id==p2R[i].myID);
  //           List<Relationship> partnerRel=partner.relationships;
  //           partnerRel.add(Relationship(myID: c.id, myType: RelationshipType.child));
  //           cR.add(Relationship(myID: partner.id, myType: RelationshipType.parent));
  //          await edit(replaceID: partner.id,newRelationships: partnerRel.toSet().toList());

  //           break;
  //         case RelationshipType.child:
  //         Person sib = state.singleWhere((p)=>p.id==p2R[i].myID);
  //           List<Relationship> sibR=sib.relationships;
  //           sibR.add(Relationship(myID: c.id, myType: RelationshipType.sibling));
  //           cR.add(Relationship(myID: sib.id, myType: RelationshipType.sibling));
  //          await edit(replaceID: sib.id,newRelationships: sibR.toSet().toList());
  //           break;
  //         default: break;
  //       }}
  //   }
  //   }
  //   await edit(replaceID: child, newRelationships: cR.toSet().toList());
  //   await edit(replaceID: child, newParentID: cParents);
  // }
  // Future<bool> canMarry(String myID) async
  // {
  //   Person me=state.singleWhere((s)=>s.id==myID);
  //   List<Relationship> mePartners = me.relationships.where((r)=>r.myType==RelationshipType.partner).toList();
  //   return (allowedToPartner[me.age]!.isNotEmpty && 
  //           (mePartners.length < me.maxSpouse));
  // }
  // Future<List<String?>> partnersAndExes(String myID) async
  // {
  //   var me=state.singleWhere((p)=>p.id==myID);
  //   return [...me.partnerID,...me.exIDs];
  // }
  // Future<String> adoption(List<String> myAncestry) async
  // {
  //   // final adoptionAges={AgeType.quiteYoung,AgeType.young};
  //   final adoptionAges= AgeType.values.where((at)=>at.index <= AgeType.young.index).toSet();
  //   final children=state.where((c)=>
  //     (adoptionAges.contains(c.age))
  //     &&
  //     (c.parents.isEmpty)
  //     &&
  //     (myAncestry.contains(c.ancestry)));
  //   return children.elementAt(random.nextInt(children.length)).id;
    
  // }
  // Future<List<Person>> personWho(bool Function(dynamic element) condition) async{return state.where(condition).toList();}
  // //Code to work with old Jsons:
  // Future<void> oldJsonToShopRoles({required String jsonString, ShopType? myShop}) async{
  //   var xList=json.decode(jsonString) as List;
  //   LocationRole locationRole;
  //   List<String> myList;
  //     for(var i = 0; i < xList.length; i++)
  //     {
  //       myList=[];
  //       var x = xList[i];
  //       switch(myShop)
  //       {
  //         case ShopType.tavern:
  //             locationRole=LocationRole(myRole: Role.owner, locationID: x["ID"], specialty: "");
  //             addLocationRoleToPerson(myID: x["OwnerID"][0], myRole: locationRole);
  //             myList=(x["WaitStaff"]as List<dynamic>).cast<String>();
  //             for(int j=0; j<myList.length; j++)
  //               {
  //                 addLocationRoleToPerson(myID: myList[j],
  //                  myRole: LocationRole(myRole: Role.waitstaff, locationID: x["ID"], specialty: ""));
  //               }
  //             myList=(x["Cooks"]as List<dynamic>).cast<String>();
  //             for(int j=0; j<myList.length; j++)
  //               {
  //                 addLocationRoleToPerson(myID: myList[j],
  //                  myRole: LocationRole(myRole: Role.cook, locationID: x["ID"], specialty: ""));
  //               }
  //               myList=(x["Entertainers"] as List<dynamic>).cast<String>();
  //             for(int j=0; j<myList.length; j++)
  //               {
  //                 addLocationRoleToPerson(myID: myList[j],
  //                  myRole: LocationRole(myRole: Role.entertainment, locationID: x["ID"], specialty: ""));
  //               }
  //             myList=(x["Regulars"] as List<dynamic>).cast<String>();
  //             for(int j=0; j<myList.length; j++)
  //               {
  //                 addLocationRoleToPerson(myID: myList[j],
  //                  myRole: LocationRole(myRole: Role.regular, locationID: x["ID"], specialty: ""));
  //               }
  //               break;
  //         case ShopType.clothier:
  //         case ShopType.jeweler:
  //         case ShopType.herbalist:
  //         case ShopType.smith:          
  //         default:
  //             locationRole=LocationRole(myRole: Role.owner, locationID: x["ID"], specialty: "");
  //             addLocationRoleToPerson(myID: x["OwnerID"][0], myRole: locationRole);
  //             myList=(x["Apprentices"] as List<dynamic>).cast<String>();
  //             for(int j=0; j<myList.length; j++)
  //               {
  //                 addLocationRoleToPerson(myID: myList[j],
  //                  myRole: LocationRole(myRole: Role.apprentice, locationID: x["ID"], specialty: ""));
  //               }
  //             myList=(x["Journeymen"] as List<dynamic>).cast<String>();
  //             for(int j=0; j<myList.length; j++)
  //               {
  //                 addLocationRoleToPerson(myID: myList[j],
  //                  myRole: LocationRole(myRole: Role.journeyman, locationID: x["ID"], specialty: ""));
  //               }
  //               break;

  //       }
  //     }
        
  // }
  
  // Future<List<Person>> familyOf(String myID) async
  // {
  //   return state.where((p)=>
  //       p.parents.contains(myID) ||
  //       p.partnerID.contains(myID) ||
  //       p.childrenID.contains(myID) ||
  //       p.parents.map((q)=>
  //       state.firstWhere((s)=>s.id==q)).map((r)=>r.childrenID).contains(myID)).toList();
  // }

  // // Future<void> makePeople({required int numPeople,}) async{
  // //             String myAncestry;
  //             String myID;
  //             PartnerType mawwaige;
  //             List<String> otherAncestries;
  //             PolyType poly;
  //             PolyType myPoly;
  //             List<AdoptionType> childrenTypes;
  //             int rsub;
  //             String childID;
  //             String luckyOne;

  //             AgeType myAge;
  //             AgeType yourAge;
  //             int myNumPartners;
  //             List<String> createdPeople=[];
  //             List<String> theirAncestries=[];
  //             List<PolyType> theirPolyTypes=[];
  //             List<String?> myPartnersAndExes=[];

  //             bool breakInUpIsHardToDo=true;
  //             String yourID;
  //             for(int i =0; i<numPeople; i++)
  //             {

  //              myAncestry=await randomAncestry();
  //              myID=_uuid.v4();
  //              createdPeople.add(myID);
  //              theirAncestries.add(myAncestry);
  //               poly=await randomPoly(myAncestry);
  //               theirPolyTypes.add(poly);
  //               await createRandomPerson(newAncestry: myAncestry,
  //                                           newID: myID,
  //                                           newPoly: poly,
  //                                           );
  //             }

  //             for(int i=0; i < createdPeople.length;i++)
  //             {
  //               Person me=state.singleWhere((p)=>p.id==createdPeople[i]);

  //               myID=createdPeople[i];
  //               myAncestry=theirAncestries[i];
  //               myPoly=theirPolyTypes[i];
  //               myNumPartners=await numPartners(myPoly: myPoly, myAncestry: myAncestry);
  //               for(int j=0; j<myNumPartners;j++)
  //               {
  //                 breakInUpIsHardToDo=true;
  //                 if(me.canMarry())
  //                 {
  //                   while(breakInUpIsHardToDo)                              
  //                   {
  //                     mawwaige=await randomPartnerType(myAncestry);
  //                     switch(mawwaige){
  //                     case PartnerType.sameAncestry:
  //                           yourID=await findASpouse(myID, [myAncestry]);
  //                           yourID = await makePartners(myID: myID, yourID: yourID);
  //                           if(await randomBreakUp(myAncestry))
  //                           {await makeExes(myID: myID);}
  //                           else
  //                           {
  //                             breakInUpIsHardToDo=false;
  //                           }
  //                           break;
  //                     case PartnerType.differentAncestry:
  //                           otherAncestries= await getOtherAncestries(myAncestry);
  //                           yourID = await findASpouse(myID, otherAncestries);
  //                           yourID = await makePartners(myID: myID, yourID: yourID);
  //                           if(await randomBreakUp(myAncestry))
  //                           {await makeExes(myID: myID);}
  //                           else
  //                           {
  //                           breakInUpIsHardToDo=false;
  //                           }
  //                           break;
  //                       case PartnerType.noPartner:
  //                           breakInUpIsHardToDo=false;
  //                           break;

  //                   }
  //                   }
  //               }
  //              }
  //              myAge=state.singleWhere((p)=>p.id==myID).age;
  //              if(myAge.index >= AgeType.adult.index)
  //                 {
  //                 childrenTypes = await randomChildrenTypes(myAncestry);
  //                 for(AdoptionType c in childrenTypes)
  //                 {
  //                     myPartnersAndExes=await partnersAndExes(myID);
  //                     if(myPartnersAndExes.isNotEmpty)
  //                     {
  //                       luckyOne=myPartnersAndExes[random.nextInt(myPartnersAndExes.length)] ?? "Empty";
  //                       }
  //                       else
  //                       {luckyOne = "Empty";}
  //                     switch(c){
  //                       case AdoptionType.sameAncestry:
  //                           childID=await adoption([myAncestry]); 
  //                           await makeChildrenParentRelationship(parent1: myID, parent2: luckyOne, child: childID,);
  //                           break;
  //                         case AdoptionType.differentAncestry:
  //                           childID = await adoption(await getOtherAncestries(myAncestry));
  //                           await makeChildrenParentRelationship(parent1: myID, parent2: luckyOne, child: childID, );
  //                           break;
  //                         case AdoptionType.noAdoption:
  //                           childID=_uuid.v4();
                                                    
  //                           if(luckyOne=="Empty")
  //                             {yourAge=myAge;}
  //                           else
  //                             {yourAge=state.singleWhere((p)=>p.id==luckyOne).age;}
  //                           rsub=random.nextInt(2)+1;
                            
  //                           await createRandomPerson(
  //                           newID: childID,
  //                           newAge: AgeType.values[min(myAge.index,yourAge.index)-rsub],
  //                           newAncestry: myAncestry
  //                           );
  //                           await makeChildrenParentRelationship(parent1: myID, parent2: luckyOne, child: childID,);
  //                     }
  //                 }}
  //             }
  //           }
    // Future<void> makePeopleRelTable({required int numPeople,}) async{
    //           String myAncestry;
    //           String myID;
    //           PartnerType mawwaige;
    //           List<String> otherAncestries;
    //           PolyType poly;
    //           PolyType myPoly;
    //           List<AdoptionType> childrenTypes;
    //           int rsub;
    //           String childID;
    //           String luckyOne;

    //           AgeType myAge;
    //           AgeType yourAge;
    //           int myNumPartners;
    //           List<String> createdPeople=[];
    //           List<String> theirAncestries=[];
    //           List<PolyType> theirPolyTypes=[];
    //           List<String?> myPartnersAndExes=[];

    //           bool breakInUpIsHardToDo=true;
    //           String yourID;


    //           for(int i =0; i<numPeople; i++)
    //           {

    //            myAncestry=await randomAncestry();
    //            myID=_uuid.v4();
    //            createdPeople.add(myID);
    //            theirAncestries.add(myAncestry);
    //             poly=await randomPoly(myAncestry);
    //             theirPolyTypes.add(poly);
    //             await createRandomPerson(newAncestry: myAncestry,
    //                                         newID: myID,
    //                                         newPoly: poly,
    //                                         );
    //           }
    // }


  // Future<void> addJSON(String jsonString) async
  //   {
  //     var xList=json.decode(jsonString) as List;
  //     for(var i = 0; i < xList.length; i++)
  //     {
  //       var x = xList[i];
  //       await add(
  //       newFirstName: x["FirstName"],
  //       newSurname:  x["Surname"],
  //       newAncestry: x["Ancestry"],
  //       newPronouns: string2Enum(x["Pronouns"]),
  //       newAge: string2Enum(x["Age"]),
  //       newOrientation: string2Enum(x["Orientation"]),
  //       newQuirk1: x["Quirk1"],
  //       newQuirk2: x["Quirk2"],
  //       newResonantArgument: x["ResonantArgument"],
  //       newFaction: x["Faction"],
  //       newID: x["ID"],
  //       newPartnerID: [...x["PartnerID"]],
  //       newChildrenID: [...x["ChildrenID"]],
  //       newParentID: [...x["Parents"]],
  //       newExID: [...x["ExIDs"]],
  //       newPoly: string2Enum(x["Poly"]),
  //       newRoles:[],
  //       newRelationships: [],
  //       // newMaxSpouse: x["FIeld doesn't exist"];
  //     );
  //     }
  //   }

    // Future<void> createPeople(int numPeople, ref) async {
  //   List<Person> newPeople = [];
  //   List<Node> newRelationships = [];
  //   for (int i = 0; i < numPeople; i++) {
  //     String id = _uuid.v4();
  //     String myAncestry = randomAncestry();
  //     newPeople.add(createRandomPerson(newID: id, newAncestry: myAncestry));
  //     newRelationships.add(Node(id: id, relPairs: {}));
  //   }
  //   await ref.read(peopleListProvider.notifier).bulkAdd(newPeople);
  //   await ref
  //       .read(relationshipsProvider.notifier)
  //       .bulkAddNodes(newRelationships);
  // }



  // List<Widget> printDetailGov(
//       List<Person> people, WidgetRef ref, BuildContext context) {
//     List<ExpansionTile> peopleWidgets = [];
//     final roleMeta = ref.watch(ref.read(myWorldProvider).allRoles.notifier);
//     final locationRoleList =
//         ref.watch(ref.watch(townProvider).locationRoleListProvider);
//     final locations = ref.watch(ref.watch(townProvider).locationsListProvider);
//     List<LocationRole> theseRoles =
//         locationRoleList.where((lr) => lr.locationID == id).toList();
//     List<String> specialties = theseRoles
//         .map((lr) => lr.specialty)
//         .toSet()
//         .toList()
//       ..sort((a, b) => a.compareTo(b));

//     // Sort roles alphabetically based on their string representation

//     for (int i = 0; i < specialties.length; i++) {
//       final thisRole = specialties.elementAt(i);
//       Set<String> roleIDs = locationRoleList
//           .where((lr) => lr.locationID == id && lr.specialty == thisRole)
//           .map((lr) => lr.myID)
//           .toSet();

//       var thePeopleInTheRoleHere =
//           people.where((p) => roleIDs.contains(p.id)).toList();
//       // if (thisRole == Role.owner) {
//       //   Set<String> allOwnerIDs = allRoles
//       //       .where((lr) => lr.myRole == thisRole)
//       //       .map((lr) => lr.myID)
//       //       .toSet();
//       //   thePeopleInTheRoleHere = people.where((p) => allOwnerIDs.contains(p.id)).toList();
//       // }

//       String headerString = thisRole;

//       List<Widget> myRoleWidgets = [];
//       for (int j = 0; j < thePeopleInTheRoleHere.length; j++) {
//         List<String> shopString;
//         int locRoleIndex = locationRoleList.indexWhere((lr) =>
//             lr.locationID == infoID && lr.myID == thePeopleInTheRoleHere[j].id);
//         if (locRoleIndex == -1) {
//           shopString = ["Adopted"];
//         } else {
//           shopString = [
//             roleMeta.getString(locationRoleList[locRoleIndex].myRole)
//           ];
//         }

//         final locRole = locationRoleList
//             .where((lr) =>
//                 lr.myID == thePeopleInTheRoleHere[j].id &&
//                 !{governtmentID, infoID, informationalID, marketID}
//                     .contains(lr.locationID))
//             .toList();
//         for (int i = 0; i < locRole.length; i++) {
//           final lr = locRole[i];
//           final loc = locations.firstWhere((l) => l.id == lr.locationID);
//           if (lr.myRole == Role.owner) {
//             shopString.add("Owner of ${loc.name} : ${(loc as Shop).type.name}");
//           } else {
//             shopString.add("${roleMeta.getString(lr.myRole)} at ${loc.name}");
//           }
//           if (i + 1 < locRole.length) {
//             // shopString.add("\n");
//           }
//         }

//         myRoleWidgets.add(thePeopleInTheRoleHere[j]
//             .printPersonSummaryTappable(context, additionalInfo: shopString));
//       }

//       if (myRoleWidgets.isNotEmpty) {
//         List<Widget> expansionChildren = [...myRoleWidgets];

//         peopleWidgets.add(
//           ExpansionTile(
//             title: Text(headerString),
//             expandedAlignment: Alignment.topLeft,
//             expandedCrossAxisAlignment: CrossAxisAlignment.start,
//             children: expansionChildren,
//           ),
//         );
//       }
//     }

//     return [...peopleWidgets];
//   }
// }

// extension TownLocations on Town {

//   Future<void> addRandomShop(ShopType myType, WidgetRef ref) async {
//     List<Person> cachedPeople = List<Person>.from(ref.read(peopleListProvider));
//     List<LocationRole> cachedLocationRoles =
//         List<LocationRole>.from(ref.read(locationRoleListProvider));
//     List<Node> cachedRelationships =
//         List<Node>.from(ref.read(relationshipsProvider));
//     final locRoleProvider = ref.read(locationRoleListProvider.notifier);
//     final locProvider = ref.read(locationsListProvider.notifier);

//     List<Function> updateBuffer = List.empty(growable: true);

//     bool isNotEmployed(String p) {
//       return cachedLocationRoles.where((lr) => lr.myID == p).isEmpty;
//     }

//     bool regularEligible(String p) {
//       Set<Role> regEl = {};
//       regEl.addAll(roleLookup[ShopType.smith]!.toSet());
//       regEl.addAll(roleLookup[ShopType.clothier]!.toSet());
//       regEl.addAll(roleLookup[ShopType.herbalist]!.toSet());
//       regEl.addAll(roleLookup[ShopType.jeweler]!.toSet());
//       regEl.addAll(roleLookup[LocationType.info]!.toSet());
//       regEl.addAll(roleLookup[LocationType.hireling]!.toSet());
//       regEl.addAll(roleLookup[LocationType.market]!.toSet());
//       return cachedLocationRoles
//           .where((lr) => lr.myID == p && regEl.contains(lr.myRole))
//           .isNotEmpty;
//     }

//     List<String> relationshipWhere(
//         String p, List<RelationshipType> relationshipTypes) {
//       return cachedRelationships
//           .firstWhere((r) => r.id == p)
//           .relPairs
//           .where((rp) => relationshipTypes.contains(rp.iAmYour))
//           .map((rp) => rp.you)
//           .toList();
//     }

//     String newShopName(
//         {required List<String> ownerFirstNames,
//         required List<String> ownerSurnames,
//         required ShopType shopType}) {
//       double r = random.nextDouble();
//       bool firstSecond = r < 0.65;
//       bool ownerFirstShopSecond = r < 0.75;
//       bool ownerLastShopSecond = r < 0.9;
//       bool ownerFirstShopFirstShopSecond = r < -0.95;
//       bool ownerLastShopFirstShopSecond = r < 1;

//       List<ShopName> myShopWords =
//           shopNames.where((n) => n.shopType == shopType).toList();
//       List<String> shopFirstWords = myShopWords
//           .where((w) => w.wordType == WordType.first)
//           .map((w) => w.word)
//           .toList();
//       List<String> shopSecondWords = myShopWords
//           .where((w) => w.wordType == WordType.second)
//           .map((w) => w.word)
//           .toList();
//       List<String> shopNameWords = myShopWords
//           .where((w) => w.wordType == WordType.withName)
//           .map((w) => w.word)
//           .toList();

//       String rOwnerFN = ownerFirstNames[random.nextInt(ownerFirstNames.length)];
//       String rOwnerLN = ownerSurnames[random.nextInt(ownerSurnames.length)];
//       String rShopFW = shopFirstWords[random.nextInt(shopFirstWords.length)];
//       String rShopSW = shopSecondWords[random.nextInt(shopSecondWords.length)];
//       String rShopNW = shopNameWords[random.nextInt(shopNameWords.length)];

//       if (firstSecond) {
//         return "$rShopFW $rShopSW";
//       }
//       if (ownerFirstShopSecond) {
//         return "$rOwnerFN's $rShopSW";
//       }
//       if (ownerLastShopSecond) {
//         return "$rOwnerLN's $rShopSW";
//       }
//       if (ownerFirstShopFirstShopSecond) {
//         return "$rOwnerFN's $rShopNW $rShopSW";
//       }
//       if (ownerLastShopFirstShopSecond) {
//         return "$rOwnerLN's $rShopNW $rShopSW";
//       }
//       return "******Shouldn't See This*******";
//     }

//     List<Person> ownerList = [];
//     String myShopID = _uuid.v4();
//     var myQuirks = random3Quirks(ref, myShopType: myType);
//     String pro1 = myQuirks["pro1"]!;
//     String pro2 = myQuirks["pro2"]!;
//     String con = myQuirks["con"]!;
//     String newName = "";

//     int staffMultiplier = 1;
//     if ({pro1, pro2}.intersection({"Well staffed", "Popular"}).isNotEmpty) {
//       staffMultiplier = 2;
//     } else if ({con}
//         .intersection({"Not well staffed", "Unpopular"}).isNotEmpty) {
//       staffMultiplier = 0;
//     }

//     int entertainMultiplier = 1;
//     if ({pro1, pro2}
//         .intersection({"Great Music", "Great Storytelling"}).isNotEmpty) {
//       entertainMultiplier = 2;
//     }

//     bool twoOwners = random.nextDouble() < 0.05;
//     bool familyBusiness = random.nextDouble() < 0.5;

//     List<Role> roleTypes = roleLookup[myType] ?? defaultRoles;

//     Role myRole;
//     int howMany = 1;
//     Set<AgeType> validAges;
//     Set<AgeType> adultOrMore = {
//       AgeType.adult,
//       AgeType.middleAge,
//       AgeType.old,
//       AgeType.quiteOld
//     };
//     Set<AgeType> children =
//         AgeType.values.where((at) => (at).index < AgeType.adult.index).toSet();
//     Set<AgeType> typicalWork = {AgeType.adult, AgeType.middleAge, AgeType.old};

//     List<RelationshipType> familyToAddOnHire = [RelationshipType.partner];
//     for (int i = 0; i < roleTypes.length; i++) {
//       myRole = roleTypes[i];
//       switch (myRole) {
//         case Role.owner:
//           howMany = 1;
//           if (twoOwners) {
//             howMany = 2;
//           }
//           validAges = adultOrMore;
//           familyToAddOnHire = [
//             RelationshipType.partner,
//             RelationshipType.sibling,
//             RelationshipType.child
//           ];
//           break;
//         case Role.apprentice:
//           howMany = 1 * staffMultiplier;
//           validAges = children;
//           familyToAddOnHire = [
//             RelationshipType.parent,
//             RelationshipType.sibling
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.journeyman:
//           howMany = 2 * staffMultiplier;
//           validAges = {AgeType.adult};
//           familyToAddOnHire = [
//             RelationshipType.parent,
//             RelationshipType.sibling
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.entertainment:
//           howMany = 1 * staffMultiplier * entertainMultiplier;
//           validAges = typicalWork;
//           familyToAddOnHire = [
//             RelationshipType.partner,
//             RelationshipType.sibling,
//             RelationshipType.child
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.regular:
//           howMany = 20;
//           validAges = adultOrMore;
//           familyToAddOnHire = [
//             RelationshipType.parent,
//             RelationshipType.sibling,
//             RelationshipType.child,
//             RelationshipType.friend,
//             RelationshipType.partner
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.customer:
//           howMany = 5;
//           validAges = adultOrMore;
//           familyToAddOnHire = [
//             RelationshipType.parent,
//             RelationshipType.sibling,
//             RelationshipType.child,
//             RelationshipType.friend,
//             RelationshipType.partner
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.cook:
//           howMany = 1 * staffMultiplier;
//           validAges = typicalWork;
//           familyToAddOnHire = [
//             RelationshipType.partner,
//             RelationshipType.sibling,
//             RelationshipType.child
//           ]; // iAmYour==parent, sibling, etc

//           break;
//         case Role.waitstaff:
//           howMany = 2 * staffMultiplier;
//           validAges = typicalWork;
//           familyToAddOnHire = [
//             RelationshipType.partner,
//             RelationshipType.sibling,
//             RelationshipType.child
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         default:
//           howMany = 0;
//           validAges = {};
//           familyToAddOnHire = [RelationshipType.partner];
//       }

//       List<String> familyOfCurrentWorkersIDs = [];
//       List<String> possibleWorkers = [];
//       if ({Role.regular, Role.customer}.contains(myRole)) {
//         possibleWorkers = cachedPeople
//             .where(
//                 (p) => ((regularEligible(p.id)) && validAges.contains(p.age)))
//             .map((p) => p.id)
//             .toList();
//       } else {
//         possibleWorkers = cachedPeople
//             .where((p) => ((isNotEmployed(p.id)) && validAges.contains(p.age)))
//             .map((p) => p.id)
//             .toList();
//       }

//       for (int j = 0; j < howMany; j++) {
//         //         // print("$myRole Family Workers: ${familyWorkers.length}");

//         String worker;
//         if (familyBusiness || myRole == Role.regular) {
//           final x = familyOfCurrentWorkersIDs
//               .toSet()
//               .intersection(possibleWorkers.toSet());
//           if (x.isNotEmpty) {
//             worker = randomElement(x.toList());
//           } else {
//             worker = randomElement(possibleWorkers);
//           }
//           familyOfCurrentWorkersIDs
//               .addAll(relationshipWhere(worker, familyToAddOnHire));
//         } else {
//           worker = randomElement(possibleWorkers);
//         }

//         possibleWorkers.removeWhere((p) => p == worker);

//         if (myRole == Role.owner) {
//           ownerList.add(cachedPeople.firstWhere((p) => p.id == worker));
//         }
//         LocationRole locRole = LocationRole(
//             locationID: myShopID, myID: worker, myRole: myRole, specialty: "");

//         cachedLocationRoles.add(locRole);
//         updateBuffer.add(() async => (locRoleProvider).add(addMe: locRole));
//       }
//     }

//     newName = newShopName(
//         ownerFirstNames: ownerList.map((o) => o.firstName).toList(),
//         ownerSurnames: ownerList.map((o) => o.surname).toList(),
//         shopType: myType);

//     Shop newShop = Shop(
//         con: con,
//         pro1: pro1,
//         pro2: pro2,
//         blurbText: "$pro1 & $pro2 but $con",
//         name: newName,
//         type: myType,
//         myID: myShopID);

//     // print(myShopID);
//     updateBuffer.add(() async => locProvider.add(addMe: newShop));
//     for (final update in updateBuffer) {
//       await update();
//     }
//   }

//   Map<String, String> random3Quirks(WidgetRef ref, {required myShopType}) {
//     final shopQualities = ref.watch(shopQualitiesProvider);
//     final applicable =
//         shopQualities.where((q) => q.type == myShopType).toList();

//     Set<int> randomNumbers = {};

//     while (randomNumbers.length < 3) {
//       randomNumbers.add(random.nextInt(applicable.length));
//     }
//     final my3 = randomNumbers.toList();
//     return <String, String>{
//       "pro1": applicable[my3[0]].pro,
//       "pro2": applicable[my3[1]].pro,
//       "con": applicable[my3[2]].con
//     };
//   }

//   // Future<void> addRandomShop2(
//   //     ShopType myType, WidgetRef ref, String ownerID) async {
//   //   List<Person> cachedPeople = List<Person>.from(ref.read(peopleListProvider));
//   //   List<LocationRole> cachedLocationRoles =
//   //       List<LocationRole>.from(ref.read(locationRoleListProvider));
//   //   List<RoleGeneration> cachedRoleGeneration =
//   //       List<RoleGeneration>.from(ref.read(ref.read(myWorldProvider).allRoles));
//   //   List<Node> cachedRelationships =
//   //       List<Node>.from(ref.read(relationshipsProvider));
//   //   final locRoleProvider = ref.read(locationRoleListProvider.notifier);
//   //   final locProvider = ref.read(locationsListProvider.notifier);
//   //   final locSearchProvider = ref.read(locationSearch.notifier);
//   //   final peopleSearchProvider = ref.read(peopleSearch.notifier);

//   //   List<Function> updateBuffer = List.empty(growable: true);

//   //   bool isNotEmployed(String p) {
//   //     return cachedLocationRoles.where((lr) => lr.myID == p).isEmpty;
//   //   }

//   //   List<String> relationshipWhere(
//   //       String p, List<RelationshipType> relationshipTypes) {
//   //     return cachedRelationships
//   //         .firstWhere((r) => r.id == p)
//   //         .relPairs
//   //         .where((rp) => relationshipTypes.contains(rp.iAmYour))
//   //         .map((rp) => rp.you)
//   //         .toList();
//   //   }

//   //   String newShopName(
//   //       {required List<String> ownerFirstNames,
//   //       required List<String> ownerSurnames,
//   //       required ShopType shopType}) {
//   //     double r = random.nextDouble();
//   //     bool firstSecond = r < 0.65;
//   //     bool ownerFirstShopSecond = r < 0.75;
//   //     bool ownerLastShopSecond = r < 0.9;
//   //     bool ownerFirstShopFirstShopSecond = r < -0.95;
//   //     bool ownerLastShopFirstShopSecond = r < 1;

//   //     String rShopFW;
//   //     String rShopSW;
//   //     String rShopNW;

//   //     String randomAlignment() {
//   //       double r = random.nextDouble();
//   //       if (r < 0.2) {
//   //         return "Lawful Good";
//   //       }
//   //       if (r < 0.4) {
//   //         return "Neutral Good";
//   //       }
//   //       if (r < 0.5) {
//   //         return "Chaotic Good";
//   //       }
//   //       if (r < 0.6) {
//   //         return "Lawful Neutral";
//   //       }
//   //       if (r < 0.7) {
//   //         return "True Neutral";
//   //       }
//   //       if (r < 0.85) {
//   //         return "Chaotic Neutral";
//   //       }
//   //       if (r < 0.9) {
//   //         return "Lawful Evil";
//   //       }
//   //       if (r < 0.95) {
//   //         return "Neutral Evil";
//   //       }
//   //       if (r < 0.99) {
//   //         return "Chaotic Evil";
//   //       }
//   //       return "Unaligned";
//   //     }

//   //     if (shopType == ShopType.temple) {
//   //       String alignment = randomAlignment();
//   //       return "Temple to a $alignment Deity";
//   //     }

//   //     List<ShopName> myShopWords =
//   //         shopNames.where((n) => n.shopType == shopType).toList();
//   //     List<String> shopFirstWords = myShopWords
//   //         .where((w) => w.wordType == WordType.first)
//   //         .map((w) => w.word)
//   //         .toList();
//   //     List<String> shopSecondWords = myShopWords
//   //         .where((w) => w.wordType == WordType.second)
//   //         .map((w) => w.word)
//   //         .toList();
//   //     List<String> shopNameWords = myShopWords
//   //         .where((w) => w.wordType == WordType.withName)
//   //         .map((w) => w.word)
//   //         .toList();

//   //     String rOwnerFN = ownerFirstNames[random.nextInt(ownerFirstNames.length)];
//   //     String rOwnerLN = ownerSurnames[random.nextInt(ownerSurnames.length)];

//   //     rShopFW = shopFirstWords[random.nextInt(shopFirstWords.length)];
//   //     rShopSW = shopSecondWords[random.nextInt(shopSecondWords.length)];
//   //     rShopNW = shopNameWords[random.nextInt(shopNameWords.length)];

//   //     if (firstSecond) {
//   //       return "$rShopFW $rShopSW";
//   //     }
//   //     if (ownerFirstShopSecond) {
//   //       return "$rOwnerFN's $rShopSW";
//   //     }
//   //     if (ownerLastShopSecond) {
//   //       return "$rOwnerLN's $rShopSW";
//   //     }
//   //     if (ownerFirstShopFirstShopSecond) {
//   //       return "$rOwnerFN's $rShopNW $rShopSW";
//   //     }
//   //     if (ownerLastShopFirstShopSecond) {
//   //       return "$rOwnerLN's $rShopNW $rShopSW";
//   //     }
//   //     return "******Shouldn't See This*******";
//   //   }

//   //   List<Person> ownerList = [];
//   //   String myShopID = _uuid.v4();
//   //   var myQuirks = random3Quirks(myShopType: myType);
//   //   String pro1 = myQuirks["pro1"]!;
//   //   String pro2 = myQuirks["pro2"]!;
//   //   String con = myQuirks["con"]!;
//   //   String newName = "";
//   //   // int counter=0;
//   //   int staffMultiplier = 1;
//   //   if ({pro1, pro2}.intersection({"Well staffed", "Popular"}).isNotEmpty) {
//   //     staffMultiplier = 2;
//   //   } else if ({con}
//   //       .intersection({"Not well staffed", "Unpopular"}).isNotEmpty) {
//   //     staffMultiplier = 0;
//   //   }

//   //   int entertainMultiplier = 1;
//   //   if ({pro1, pro2}
//   //       .intersection({"Great Music", "Great Storytelling"}).isNotEmpty) {
//   //     entertainMultiplier = 2;
//   //   }

//   //   bool twoOwners = random.nextDouble() < 0.05;
//   //   bool familyBusiness = random.nextDouble() < 0.5;

//   //   List<Role> roleTypes = roleLookup[myType] ?? defaultRoles;

//   //   Role myRole;
//   //   int howMany = 1;
//   //   Set<AgeType> validAges;
//   //   Set<AgeType> adultOrMore = {
//   //     AgeType.adult,
//   //     AgeType.middleAge,
//   //     AgeType.old,
//   //     AgeType.quiteOld
//   //   };
//   //   Set<AgeType> children =
//   //       AgeType.values.where((at) => (at).index < AgeType.adult.index).toSet();
//   //   Set<AgeType> typicalWork = {AgeType.adult, AgeType.middleAge, AgeType.old};

//   //   List<RelationshipType> familyToAddOnHire = [RelationshipType.partner];

//   //   for (int i = 0; i < roleTypes.length; i++) {
//   //     myRole = roleTypes[i];
//   //     switch (myRole) {
//   //       case Role.owner:
//   //         howMany = 1;
//   //         if (twoOwners) {
//   //           howMany = 2;
//   //         }
//   //         validAges = adultOrMore;
//   //         familyToAddOnHire = [
//   //           RelationshipType.partner,
//   //           RelationshipType.sibling,
//   //           RelationshipType.child
//   //         ];
//   //         break;
//   //       case Role.apprentice:
//   //         howMany = 1 * staffMultiplier;
//   //         validAges = children;
//   //         familyToAddOnHire = [
//   //           RelationshipType.parent,
//   //           RelationshipType.sibling
//   //         ]; // iAmYour==parent, sibling, etc
//   //         break;
//   //       case Role.journeyman:
//   //         howMany = 2 * staffMultiplier;
//   //         validAges = {AgeType.adult};
//   //         familyToAddOnHire = [
//   //           RelationshipType.parent,
//   //           RelationshipType.sibling
//   //         ]; // iAmYour==parent, sibling, etc
//   //         break;
//   //       case Role.entertainment:
//   //         howMany = 1 * staffMultiplier * entertainMultiplier;
//   //         validAges = typicalWork;
//   //         familyToAddOnHire = [
//   //           RelationshipType.partner,
//   //           RelationshipType.sibling,
//   //           RelationshipType.child
//   //         ]; // iAmYour==parent, sibling, etc
//   //         break;
//   //       case Role.regular:
//   //         howMany = 20;
//   //         validAges = adultOrMore;
//   //         familyToAddOnHire = [
//   //           RelationshipType.parent,
//   //           RelationshipType.sibling,
//   //           RelationshipType.child,
//   //           RelationshipType.friend,
//   //           RelationshipType.partner
//   //         ]; // iAmYour==parent, sibling, etc
//   //         break;
//   //       case Role.customer:
//   //         howMany = 5;
//   //         validAges = adultOrMore;
//   //         familyToAddOnHire = [
//   //           RelationshipType.parent,
//   //           RelationshipType.sibling,
//   //           RelationshipType.child,
//   //           RelationshipType.friend,
//   //           RelationshipType.partner
//   //         ]; // iAmYour==parent, sibling, etc
//   //         break;
//   //       case Role.cook:
//   //         howMany = 1 * staffMultiplier;
//   //         validAges = typicalWork;
//   //         familyToAddOnHire = [
//   //           RelationshipType.partner,
//   //           RelationshipType.sibling,
//   //           RelationshipType.child
//   //         ]; // iAmYour==parent, sibling, etc

//   //         break;
//   //       case Role.waitstaff:
//   //         howMany = 2 * staffMultiplier;
//   //         validAges = typicalWork;
//   //         familyToAddOnHire = [
//   //           RelationshipType.partner,
//   //           RelationshipType.sibling,
//   //           RelationshipType.child
//   //         ]; // iAmYour==parent, sibling, etc
//   //         break;
//   //       case Role.acolyte:
//   //         howMany = 4;
//   //         validAges = typicalWork;
//   //         validAges.add(AgeType.young);
//   //         break;
//   //       default:
//   //         howMany = 0;
//   //         validAges = {};
//   //         familyToAddOnHire = [RelationshipType.partner];
//   //     }

//   //     List<String> familyOfCurrentWorkersIDs = [];
//   //     List<String> possibleWorkers = [];
//   //     if (myRole == Role.customer) {
//   //       Set<Role> customerRoles = cachedRoleGeneration
//   //           .where((rg) => rg.prioritizeCustomer)
//   //           .map((rg) => rg.thisRole)
//   //           .toSet();
//   //       if (myType == ShopType.magic) {
//   //         customerRoles = customerRoles.intersection(
//   //             {Role.mercenary, Role.sage, Role.herbalist, Role.hierophant});
//   //       }
//   //       possibleWorkers = cachedLocationRoles
//   //           .where((lr) =>
//   //               (lr.locationID == infoID && customerRoles.contains(lr.myRole)))
//   //           .map((lr) => lr.myID)
//   //           .toList();
//   //     } else if (myRole == Role.regular) {
//   //       Set<Role> regularRoles;
//   //       if (random.nextDouble() < 0.5) {
//   //         regularRoles = cachedRoleGeneration
//   //             .where((rg) => rg.priorityInTaverns)
//   //             .map((rg) => rg.thisRole)
//   //             .toSet();
//   //       } else {
//   //         regularRoles = cachedRoleGeneration
//   //             .where((rg) => rg.promoteInTaverns)
//   //             .map((rg) => rg.thisRole)
//   //             .toSet();
//   //       }
//   //       possibleWorkers = cachedLocationRoles
//   //           .where((lr) =>
//   //               (lr.locationID == infoID && regularRoles.contains(lr.myRole)))
//   //           .map((lr) => lr.myID)
//   //           .toList();
//   //     } else {
//   //       possibleWorkers = cachedPeople
//   //           .where((p) => ((isNotEmployed(p.id)) && validAges.contains(p.age)))
//   //           .map((p) => p.id)
//   //           .toList();
//   //     }
//   //     possibleWorkers.removeWhere((id) => id == ownerID);

//   //     int j = 0;

//   //     if (myRole == Role.owner || myRole == Role.hierophant) {
//   //       String worker = ownerID;
//   //       ownerList.add(cachedPeople.firstWhere((p) => p.id == ownerID));
//   //       final locRole = LocationRole(
//   //           locationID: myShopID, myID: worker, myRole: myRole, specialty: "");

//   //       cachedLocationRoles.add(locRole);
//   //       updateBuffer.add(() async => locRoleProvider.add(addMe: locRole));
//   //       j = 1;
//   //     }
//   //     for (j; j < howMany; j++) {
//   //       String worker;

//   //       if (possibleWorkers.isNotEmpty) {
//   //         if (familyBusiness) {
//   //           final x = familyOfCurrentWorkersIDs
//   //               .toSet()
//   //               .intersection(possibleWorkers.toSet());
//   //           if (x.isNotEmpty) {
//   //             worker = randomElement(x.toList());
//   //           } else {
//   //             worker = randomElement(possibleWorkers);
//   //           }
//   //           familyOfCurrentWorkersIDs
//   //               .addAll(relationshipWhere(worker, familyToAddOnHire));
//   //           possibleWorkers.removeWhere((p) => p == worker);
//   //         } else {
//   //           worker = randomElement(possibleWorkers);
//   //           possibleWorkers.removeWhere((p) => p == worker);
//   //         }
//   //       } else {
//   //         final workerAsPerson =
//   //             createRandomPerson(newAge: randomElement(validAges.toList()));
//   //         worker = workerAsPerson.id;
//   //         updateBuffer.add(
//   //             () async => ref.read(peopleListProvider).add(workerAsPerson));
//   //         updateBuffer.add(() async =>
//   //             peopleSearchProvider.addPersonToSearch(workerAsPerson));
//   //         final n = Node(id: worker, relPairs: {});
//   //         updateBuffer.add(() async => ref.read(relationshipsProvider).add(n));
//   //       }

//   //       final locRole = LocationRole(
//   //           locationID: myShopID, myID: worker, myRole: myRole, specialty: "");
//   //       // counter++;
//   //       cachedLocationRoles.add(locRole);
//   //       updateBuffer.add(() async => (locRoleProvider).add(addMe: locRole));
//   //     }
//   //   }
//   //   // print("Yo");
//   //   newName = newShopName(
//   //       ownerFirstNames: ownerList.map((o) => o.firstName).toList(),
//   //       ownerSurnames: ownerList.map((o) => o.surname).toList(),
//   //       shopType: myType);

//   //   List<GenericService> applicableGenericServices =
//   //       (ref.read(myWorldProvider).genericServices)
//   //           .where((g) => g.whereAvailable.contains(myType))
//   //           .toList();
//   //   int numServices = 8;
//   //   Set<String> limitedSelect = {"Limited Selection", "Not well stocked"};
//   //   Set<String> bigSelect = {"Great Selection", "Well stocked"};

//   //   if (limitedSelect.contains(con)) {
//   //     numServices = 4;
//   //   }
//   //   if ({pro1, pro2}.intersection(bigSelect).isNotEmpty) {
//   //     numServices = 16;
//   //   }

//   //   List<int> randomNumbers = List.empty(growable: true);
//   //   for (int i = 0;
//   //       i < min(numServices, applicableGenericServices.length);
//   //       i++) {
//   //     int x = random.nextInt(applicableGenericServices.length);
//   //     while (randomNumbers.contains(x)) {
//   //       x = random.nextInt(applicableGenericServices.length);
//   //     }
//   //     randomNumbers.add(x);
//   //   }
//   //   List<Service> services = List.empty(growable: true);

//   //   Map<String, List<ServiceType>> pro2types = {
//   //     "Great Food": [ServiceType.food],
//   //     "Specializes in Weapons": [ServiceType.weapon],
//   //     "Specializes in Armor": [ServiceType.armor],
//   //     "Specializes in Adventuring Gear": [ServiceType.adventure],
//   //     "Specializes in Healing": [ServiceType.potion],
//   //     "Specializes in Remedies": [ServiceType.potion],
//   //     "Specializes in adventuring gear": [ServiceType.adventure],
//   //     "Caters to adventurers' needs": [ServiceType.adventure],
//   //     "Specializes in Potions": [ServiceType.potion],
//   //     "Specializes in Scrolls": [ServiceType.scroll],
//   //   };

//   //   Set<ServiceType> mySpecialties = {};
//   //   if (pro2types[pro1] != null) {
//   //     mySpecialties.addAll(pro2types[pro1]!);
//   //   }
//   //   if (pro2types[pro2] != null) {
//   //     mySpecialties.addAll(pro2types[pro2]!);
//   //   }

//   //   List<Specialty> applicableSpecialties;
//   //   for (var x in randomNumbers) {
//   //     String desc = applicableGenericServices[x].description;
//   //     if (mySpecialties
//   //         .intersection(applicableGenericServices[x].serviceType.toSet())
//   //         .isNotEmpty) {
//   //       applicableSpecialties = ref
//   //           .watch(myWorldProvider)
//   //           .allSpecialties
//   //           .where((s) =>
//   //               s.appliesTo.toSet().intersection(mySpecialties).isNotEmpty)
//   //           .toList();
//   //       if (applicableSpecialties.isNotEmpty) {
//   //         Specialty randSpec = randomElement(applicableSpecialties);
//   //         desc = "$desc (${randSpec.description})";
//   //       }
//   //     }

//   //     services.add(Service(
//   //       cost: applicableGenericServices[x].price,
//   //       description: desc,
//   //     ));
//   //   }

//   //   Shop newShop = Shop(
//   //       con: con,
//   //       pro1: pro1,
//   //       pro2: pro2,
//   //       blurbText: "$pro1 & $pro2 but $con",
//   //       name: newName,
//   //       type: myType,
//   //       myID: myShopID,
//   //       myServices: services);

//   //   // print(myShopID);
//   //   updateBuffer.add(() async => locProvider.add(addMe: newShop));
//   //   updateBuffer.add(() async => locSearchProvider.addShopToSearch(newShop));
//   //   // print("Shop Name: $newName, counter:$counter");

//   //   for (final update in updateBuffer) {
//   //     try {
//   //       await update();
//   //     } catch (e, stackTrace) {
//   //       print("Error executing update: $e\n$stackTrace");
//   //     }
//   //   }
//   // }

// Future<void> addRandomShopNoCommit(
//       ShopType myType, WidgetRef ref, String ownerID) async {
    
//     final people = ref.watch(peopleProvider);
//     final peoplePN = ref.read(peopleProvider.notifier);

//     final locationRoles = ref.watch(locationRolesProvider);
//     final roleMeta = ref.read(roleMetaProvider);

//     final relationships = ref.watch(relationshipsProvider);
//     final relationshipsPN = ref.watch(relationshipsProvider.notifier);

//     final locationRolesPN = ref.read(locationRolesProvider.notifier);
    
//     final locationsPN = ref.read(locationsProvider.notifier);
    
//     final locSearchProvider = ref.read(locationSearch.notifier);
//     final peopleSearchProvider = ref.read(peopleSearch.notifier);

//     final shopNames = ref.read(shopNamesProvider);
//     final genericServices = ref.read(genericServicesProvider);
//     final specialtyServices = ref.read(specialtyServicesProvider);

//     List<Function> updateBuffer = List.empty(growable: true);

//     bool isNotEmployed(String p) {
//       return locationRoles.where((lr) => lr.myID == p).isEmpty;
//     }

//     List<String> relationshipWhere(String p, List<RelationshipType> relationshipTypes) {
//       return relationships
//           .firstWhere((r) => r.id == p)
//           .relPairs
//           .where((rp) => relationshipTypes.contains(rp.iAmYour))
//           .map((rp) => rp.you)
//           .toList();
//     }

//     String newShopName(
//         {required List<String> ownerFirstNames,
//         required List<String> ownerSurnames,
//         required ShopType shopType}) {
//       double r = random.nextDouble();
//       bool firstSecond = r < 0.65;
//       bool ownerFirstShopSecond = r < 0.75;
//       bool ownerLastShopSecond = r < 0.9;
//       bool ownerFirstShopFirstShopSecond = r < -0.95;
//       bool ownerLastShopFirstShopSecond = r < 1;

//       String rShopFW;
//       String rShopSW;
//       String rShopNW;

//       String randomAlignment() {
//         double r = random.nextDouble();
//         if (r < 0.2) {
//           return " Lawful Good";
//         }
//         if (r < 0.4) {
//           return " Neutral Good";
//         }
//         if (r < 0.5) {
//           return " Chaotic Good";
//         }
//         if (r < 0.6) {
//           return " Lawful Neutral";
//         }
//         if (r < 0.7) {
//           return " True Neutral";
//         }
//         if (r < 0.85) {
//           return " Chaotic Neutral";
//         }
//         if (r < 0.9) {
//           return " Lawful Evil";
//         }
//         if (r < 0.95) {
//           return " Neutral Evil";
//         }
//         if (r < 0.99) {
//           return " Chaotic Evil";
//         }
//         return "n Unaligned";
//       }

//       if (shopType == ShopType.temple) {
//         String alignment = randomAlignment();
//         return "Temple to a$alignment Deity";
//       }

//       List<ShopName> myShopWords =
//           shopNames.where((n) => n.shopType == shopType).toList();
//       List<String> shopFirstWords = myShopWords
//           .where((w) => w.wordType == WordType.first)
//           .map((w) => w.word)
//           .toList();
//       List<String> shopSecondWords = myShopWords
//           .where((w) => w.wordType == WordType.second)
//           .map((w) => w.word)
//           .toList();
//       List<String> shopNameWords = myShopWords
//           .where((w) => w.wordType == WordType.withName)
//           .map((w) => w.word)
//           .toList();

//       String rOwnerFN = ownerFirstNames[random.nextInt(ownerFirstNames.length)];
//       String rOwnerLN = ownerSurnames[random.nextInt(ownerSurnames.length)];

//       rShopFW = shopFirstWords[random.nextInt(shopFirstWords.length)];
//       rShopSW = shopSecondWords[random.nextInt(shopSecondWords.length)];
//       rShopNW = shopNameWords[random.nextInt(shopNameWords.length)];

//       if (firstSecond) {
//         return "$rShopFW $rShopSW";
//       }
//       if (ownerFirstShopSecond) {
//         return "$rOwnerFN's $rShopSW";
//       }
//       if (ownerLastShopSecond) {
//         return "$rOwnerLN's $rShopSW";
//       }
//       if (ownerFirstShopFirstShopSecond) {
//         return "$rOwnerFN's $rShopNW $rShopSW";
//       }
//       if (ownerLastShopFirstShopSecond) {
//         return "$rOwnerLN's $rShopNW $rShopSW";
//       }
//       return "******Shouldn't See This*******";
//     }

//     List<Person> ownerList = [];
//     String myShopID = _uuid.v4();
//     var myQuirks = random3Quirks(ref,myShopType: myType);
//     String pro1 = myQuirks["pro1"]!;
//     String pro2 = myQuirks["pro2"]!;
//     String con = myQuirks["con"]!;
//     String newName = "";
//     // int counter=0;
//     int staffMultiplier = 1;
//     if ({pro1, pro2}.intersection({"Well staffed", "Popular"}).isNotEmpty) {
//       staffMultiplier = 2;
//     } else if ({con}
//         .intersection({"Not well staffed", "Unpopular"}).isNotEmpty) {
//       staffMultiplier = 0;
//     }

//     int entertainMultiplier = 1;
//     if ({pro1, pro2}
//         .intersection({"Great Music", "Great Storytelling"}).isNotEmpty) {
//       entertainMultiplier = 2;
//     }

//     bool twoOwners = random.nextDouble() < 0.05;
//     bool familyBusiness = random.nextDouble() < 0.5;

//     List<Role> roleTypes = roleLookup[myType] ?? defaultRoles;

//     Role myRole;
//     int howMany = 1;
//     Set<AgeType> validAges;
//     Set<AgeType> adultOrMore = {
//       AgeType.adult,
//       AgeType.middleAge,
//       AgeType.old,
//       AgeType.quiteOld
//     };
//     Set<AgeType> children =
//         AgeType.values.where((at) => (at).index < AgeType.adult.index).toSet();
//     Set<AgeType> typicalWork = {AgeType.adult, AgeType.middleAge, AgeType.old};

//     List<RelationshipType> familyToAddOnHire = [RelationshipType.partner];

//     for (int i = 0; i < roleTypes.length; i++) {
//       myRole = roleTypes[i];
//       switch (myRole) {
//         case Role.owner:
//           howMany = 1;
//           if (twoOwners) {
//             howMany = 2;
//           }
//           validAges = adultOrMore;
//           familyToAddOnHire = [
//             RelationshipType.partner,
//             RelationshipType.sibling,
//             RelationshipType.child
//           ];
//           break;
//         case Role.apprentice:
//           howMany = 1 * staffMultiplier;
//           validAges = children;
//           familyToAddOnHire = [
//             RelationshipType.parent,
//             RelationshipType.sibling
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.journeyman:
//           howMany = 2 * staffMultiplier;
//           validAges = {AgeType.adult};
//           familyToAddOnHire = [
//             RelationshipType.parent,
//             RelationshipType.sibling
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.entertainment:
//           howMany = 1 * staffMultiplier * entertainMultiplier;
//           validAges = typicalWork;
//           familyToAddOnHire = [
//             RelationshipType.partner,
//             RelationshipType.sibling,
//             RelationshipType.child
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.regular:
//           howMany = 20;
//           validAges = adultOrMore;
//           familyToAddOnHire = [
//             RelationshipType.parent,
//             RelationshipType.sibling,
//             RelationshipType.child,
//             RelationshipType.friend,
//             RelationshipType.partner
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.customer:
//           howMany = 5;
//           validAges = adultOrMore;
//           familyToAddOnHire = [
//             RelationshipType.parent,
//             RelationshipType.sibling,
//             RelationshipType.child,
//             RelationshipType.friend,
//             RelationshipType.partner
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.cook:
//           howMany = 1 * staffMultiplier;
//           validAges = typicalWork;
//           familyToAddOnHire = [
//             RelationshipType.partner,
//             RelationshipType.sibling,
//             RelationshipType.child
//           ]; // iAmYour==parent, sibling, etc

//           break;
//         case Role.waitstaff:
//           howMany = 2 * staffMultiplier;
//           validAges = typicalWork;
//           familyToAddOnHire = [
//             RelationshipType.partner,
//             RelationshipType.sibling,
//             RelationshipType.child
//           ]; // iAmYour==parent, sibling, etc
//           break;
//         case Role.acolyte:
//           howMany = 4;
//           validAges = typicalWork;
//           validAges.add(AgeType.young);
//           break;
//         default:
//           howMany = 0;
//           validAges = {};
//           familyToAddOnHire = [RelationshipType.partner];
//       }

//       List<String> familyOfCurrentWorkersIDs = [];
//       List<String> possibleWorkers = [];
//       if (myRole == Role.customer) {
//         Set<Role> customerRoles = roleMeta
//             .where((rg) => rg.prioritizeCustomer)
//             .map((rg) => rg.thisRole)
//             .toSet();
//         if (myType == ShopType.magic) {
//           customerRoles = customerRoles.intersection(
//               {Role.mercenary, Role.sage, Role.herbalist, Role.hierophant});
//         }
//         possibleWorkers = locationRoles
//             .where((lr) =>
//                 (lr.locationID == infoID && customerRoles.contains(lr.myRole)))
//             .map((lr) => lr.myID)
//             .toList();
//       } else if (myRole == Role.regular) {
//         Set<Role> regularRoles;
//         if (random.nextDouble() < 0.5) {
//           regularRoles = roleMeta
//               .where((rg) => rg.priorityInTaverns)
//               .map((rg) => rg.thisRole)
//               .toSet();
//         } else {
//           regularRoles = roleMeta
//               .where((rg) => rg.promoteInTaverns)
//               .map((rg) => rg.thisRole)
//               .toSet();
//         }
//         possibleWorkers = locationRoles
//             .where((lr) =>
//                 (lr.locationID == infoID && regularRoles.contains(lr.myRole)))
//             .map((lr) => lr.myID)
//             .toList();
//       } else {
//         possibleWorkers = people
//             .where((p) => ((isNotEmployed(p.id)) && validAges.contains(p.age)))
//             .map((p) => p.id)
//             .toList();
//       }
//       possibleWorkers.removeWhere((id) => id == ownerID);

//       int j = 0;

//       if (myRole == Role.owner || myRole == Role.hierophant) {
//         String worker = ownerID;
//         ownerList.add(people.firstWhere((p) => p.id == ownerID));
//         final locRole = LocationRole(
//             locationID: myShopID, myID: worker, myRole: myRole, specialty: "");

//         locationRolesPN.add(locRole);
//         // updateBuffer.add(() async => locationRolesPN.add(addMe: locRole));
//         j = 1;
//       }
//       for (j; j < howMany; j++) {
//         String worker;

//         if (possibleWorkers.isNotEmpty) {
//           if (familyBusiness) {
//             final x = familyOfCurrentWorkersIDs
//                 .toSet()
//                 .intersection(possibleWorkers.toSet());
//             if (x.isNotEmpty) {
//               worker = randomElement(x.toList());
//             } else {
//               worker = randomElement(possibleWorkers);
//             }
//             familyOfCurrentWorkersIDs
//                 .addAll(relationshipWhere(worker, familyToAddOnHire));
//             possibleWorkers.removeWhere((p) => p == worker);
//           } else {
//             worker = randomElement(possibleWorkers);
//             possibleWorkers.removeWhere((p) => p == worker);
//           }
//         } else {
//           final workerAsPerson =
//               createRandomPerson(ref, newAge: randomElement(validAges.toList()));
//           worker = workerAsPerson.id;

//           peoplePN.add(workerAsPerson);

//           updateBuffer.add(() async =>
//               peopleSearchProvider.addPersonToSearch(workerAsPerson));
//           final n = Node(id: worker, relPairs: {});
//           relationshipsPN.add(n);
//         }

//         final locRole = LocationRole(
//             locationID: myShopID, myID: worker, myRole: myRole, specialty: "");
//         // counter++;
//         locationRolesPN.add(locRole);
//       }
//     }
//     // print("Yo");
//     newName = newShopName(
//         ownerFirstNames: ownerList.map((o) => o.firstName).toList(),
//         ownerSurnames: ownerList.map((o) => o.surname).toList(),
//         shopType: myType);

//     List<GenericService> applicableGenericServices =
//         genericServices
//             .where((g) => g.whereAvailable.contains(myType))
//             .toList();
//     int numServices = 8;
//     Set<String> limitedSelect = {"Limited Selection", "Not well stocked"};
//     Set<String> bigSelect = {"Great Selection", "Well stocked"};

//     if (limitedSelect.contains(con)) {
//       numServices = 4;
//     }
//     if ({pro1, pro2}.intersection(bigSelect).isNotEmpty) {
//       numServices = 16;
//     }

//     List<int> randomNumbers = List.empty(growable: true);
//     for (int i = 0;
//         i < min(numServices, applicableGenericServices.length);
//         i++) {
//       int x = random.nextInt(applicableGenericServices.length);
//       while (randomNumbers.contains(x)) {
//         x = random.nextInt(applicableGenericServices.length);
//       }
//       randomNumbers.add(x);
//     }
//     List<Service> services = List.empty(growable: true);

//     Map<String, List<ServiceType>> pro2types = {
//       "Great Food": [ServiceType.food],
//       "Specializes in Weapons": [ServiceType.weapon],
//       "Specializes in Armor": [ServiceType.armor],
//       "Specializes in Adventuring Gear": [ServiceType.adventure],
//       "Specializes in Healing": [ServiceType.potion],
//       "Specializes in Remedies": [ServiceType.potion],
//       "Specializes in adventuring gear": [ServiceType.adventure],
//       "Caters to adventurers' needs": [ServiceType.adventure],
//       "Specializes in Potions": [ServiceType.potion],
//       "Specializes in Scrolls": [ServiceType.scroll],
//     };

//     Set<ServiceType> mySpecialties = {};
//     if (pro2types[pro1] != null) {
//       mySpecialties.addAll(pro2types[pro1]!);
//     }
//     if (pro2types[pro2] != null) {
//       mySpecialties.addAll(pro2types[pro2]!);
//     }

//     List<Specialty> applicableSpecialties;
//     for (var x in randomNumbers) {
//       String desc = applicableGenericServices[x].description;
//       if (mySpecialties
//           .intersection(applicableGenericServices[x].serviceType.toSet())
//           .isNotEmpty) {
//         applicableSpecialties = specialtyServices
//             .where((s) =>
//                 s.appliesTo.toSet().intersection(mySpecialties).isNotEmpty)
//             .toList();
//         if (applicableSpecialties.isNotEmpty) {
//           Specialty randSpec = randomElement(applicableSpecialties);
//           desc = "$desc (${randSpec.description})";
//         }
//       }

//       services.add(Service(
//         cost: applicableGenericServices[x].price,
//         description: desc,
//       ));
//     }

//     Shop newShop = Shop(
//         con: con,
//         pro1: pro1,
//         pro2: pro2,
//         blurbText: "$pro1 & $pro2 but $con",
//         name: newName,
//         type: myType,
//         myID: myShopID,
//         myServices: services);

//     // print(myShopID);
//     locationsPN.add(newShop);
//     // updateBuffer.add(() async => locationsPN.add(addMe: newShop));
//     updateBuffer.add(() async => locSearchProvider.addShopToSearch(newShop));
//     // print("Shop Name: $newName, counter:$counter");

//     for (final update in updateBuffer) {
//       try {
//         await update();
//       } catch (e, stackTrace) {
//         print("Error executing update: $e\n$stackTrace");
//       }
//     }
//   }


//   Future<void> setupMarketHirelings(WidgetRef ref) async {
//     dynamic commitBuffer = [];
//     final locationRoles = ref.watch(locationRolesProvider);

//     final allMeta = ref.read(roleMetaProvider);

//     final locations = ref.read(locationsProvider.notifier);
//     final locationsPN = ref.read(locationsProvider.notifier);
//     commitBuffer.add(()async=> await locationsPN.commitChanges());

//     final locationRolesPN = ref.read(locationRolesProvider.notifier);
//     commitBuffer.add(()async =>await locationRolesPN.commitChanges() );

//     var updateBuffer = [];

//     List<Role> hirelingRoles =
//         allMeta.where((r) => r.hireling).map((r) => r.thisRole).toList();
//     List<Role> marketRoles =
//         allMeta.where((r) => r.showInMarket).map((r) => r.thisRole).toList();
//     List<Role> infoRoles =
//         allMeta.where((r) => r.informational).map((r) => r.thisRole).toList();

//     for (final lr
//         in locationRoles.where((lr) => lr.locationID == infoID)) {
//       if (hirelingRoles.contains(lr.myRole)) {
//         // print("hireling");
//         final locRole = LocationRole(
//             locationID: hirelingID,
//             myID: lr.myID,
//             myRole: lr.myRole,
//             specialty: lr.specialty);
//         // updateBuffer.add(() async => locationRolesPN.add(addMe: locRole));
//         locationRolesPN.add(locRole);
//       }
//       if (marketRoles.contains(lr.myRole)) {
//         // print("market");
//         final locRole = LocationRole(
//             locationID: marketID,
//             myID: lr.myID,
//             myRole: lr.myRole,
//             specialty: lr.specialty);
//         // updateBuffer.add(() async => locationRolesPN.add(addMe: locRole));
//         locationRolesPN.add(locRole);
//       }
//       if (infoRoles.contains(lr.myRole)) {
//         // print("informational");
//         final locRole = LocationRole(
//             locationID: informationalID,
//             myID: lr.myID,
//             myRole: lr.myRole,
//             specialty: lr.specialty);
//         // updateBuffer.add(() async => locationRolesPN.add(addMe: locRole));
//         locationRolesPN.add(locRole);
//       }
//     }

//     final newInfo = Informational(
//         myID: informationalID,
//         locType: LocationType.info,
//         name: "Sources of information/research");

//     final newHires = Informational(
//         myID: hirelingID, locType: LocationType.hireling, name: "Hirelings");

//     final newMarket = Informational(
//         myID: marketID, locType: LocationType.market, name: "Market");

//     // updateBuffer.add(() async => locations.add(addMe: newHires));
//     locationsPN.add(newHires);
//     // updateBuffer.add(() async => locations.add(addMe: newInfo));
//     locationsPN.add(newInfo);
//     // updateBuffer.add(() async => locations.add(addMe: newMarket));
//     locationsPN.add(newMarket);

//     for (final commit in commitBuffer) {
//       await commit();
//     }
//   }


// }

// Future<void> loadShopQualtiesFromJSON(String jsonString) async {
//   var xList = json.decode(jsonString) as List;
//   for (var i = 0; i < xList.length; i++) {
//     var x = xList[i];
//     Map<String, dynamic> sq =
//         ShopQuality(
//           pro: x["pro"],
//           con: x["con"],
//           type: string2Enum(x["type"]),
//           id: _uuid.v4(),
//         ).toJson();
//     shopQualityBox.add(jsonEncode(sq));
//   }
//   shopQualities =
//       shopQualityBox.values
//           .map((e) => ShopQuality.fromJson(e))
//           .cast<ShopQuality>()
//           .toList();
// }

// Future<void> loadShopNamesFromJSON(String jsonString) async {
//   var xList = json.decode(jsonString) as List;
//   for (var i = 0; i < xList.length; i++) {
//     var x = xList[i];
//     ShopName sn = ShopName(
//       word: x["word"],
//       shopType: string2Enum(x["shopType"]),
//       wordType: string2Enum(x["wordType"]),
//       id: _uuid.v4(),
//     );
//     shopNameBox.add(jsonEncode(sn.toJson()));
//   }
//   shopNames =
//       shopNameBox.values
//           .map((e) => ShopName.fromJson(e))
//           .cast<ShopName>()
//           .toList();
// }

// Future<void> loadResonantArgumentFromJSON(String jsonString) async {
//   var xList = json.decode(jsonString) as List;
//   for (var i = 0; i < xList.length; i++) {
//     var x = xList[i];
//     raBox.add(x["argument"]);
//   }
//   resonantArguments = raBox.values.cast<String>().toList();
// }

// Future<void> loadQuirksFromJSON(String jsonString) async {
//   var xList = json.decode(jsonString) as List;
//   for (var i = 0; i < xList.length; i++) {
//     var x = xList[i];
//     quirkBox.add(x["quirk"]);
//   }
//   quirks = quirkBox.values.cast<String>().toList();
// }

// Future<void> loadGivenNamesFromJSON(String jsonString) async {
//   var xList = json.decode(jsonString) as List;
//   for (var i = 0; i < xList.length; i++) {
//     var x = xList[i];
//     GivenName gn = GivenName(
//       name: x["name"],
//       ancestry: [...x["ancestry"]],
//       pronouns:
//           (x["pronouns"] as List<dynamic>)
//               .map((p) => string2Enum(p) as PronounType)
//               .toList(),
//       id: _uuid.v4(),
//     );

//     givenNameBox.add(jsonEncode(gn.toJson()));
//   }
//   givenNames =
//       givenNameBox.values
//           .map((e) => GivenName.fromJson(e))
//           .cast<GivenName>()
//           .toList();
// }

// Future<void> loadSurnamesFromJSON(String jsonString) async {
//   var xList = json.decode(jsonString) as List;
//   for (var i = 0; i < xList.length; i++) {
//     var x = xList[i];
//     Surname sn = Surname(
//       name: x["name"],
//       ancestry: [...x["ancestry"]],
//       id: _uuid.v4(),
//     );

//     surnameBox.add(jsonEncode(sn.toJson()));
//   }
//   surnames =
//       surnameBox.values
//           .map((e) => Surname.fromJson(e))
//           .cast<Surname>()
//           .toList();
// }

// Future<void> loadAncestriesFromJSON(String jsonString) async {
//   var xList = json.decode(jsonString) as List;

//   for (var i = 0; i < xList.length; i++) {
//     var x = xList[i];
//     Ancestry a = Ancestry(
//       name: x["name"],
//       quiteYoungProb: x["quiteYoungProb"],
//       youngProb: x["youngProb"],
//       adultProb: x["adultProb"],
//       middleAgeProb: x["middleAgeProb"],
//       oldProb: x["oldProb"],
//       quiteOldProb: x["quiteOldProb"],
//       heHimProb: x["heHimProb"],
//       sheHerProb: x["sheHerProb"],
//       theyThemProb: x["theyThemProb"],
//       heTheyProb: x["heTheyProb"],
//       sheTheyProb: x["sheTheyProb"],
//       partnerWithinProb: x["partnerWithinProb"],
//       partnerOutsideProb: x["partnerOutsideProb"],
//       breakupProb: x["breakupProb"],
//       noChildrenProb: x["noChildrenProb"],
//       childrenProb: x["childrenProb"],
//       maxChildren: x["maxChildren"],
//       adoptionWithinProb: x["adoptionWithinProb"],
//       adoptionOutsideProb: x["adoptionOutsideProb"],
//       straightProb: x["straightProb"],
//       queerProb: x["queerProb"],
//       polyProb: x["polyProb"],
//       ifPolyFliptoQueerProb: x["ifPolyFliptoQueerProb"],
//       maxPolyPartner: x["maxPolyPartner"],
//       id: x["id"],
//     );

//     ancestryBox.add(jsonEncode(a.toJson()));
//     ancestries =
//         ancestryBox.values
//             .map((e) => Ancestry.fromJson(e))
//             .cast<Ancestry>()
//             .toList();
//   }
// }

// class Town {
//   String name;
//   String id;

//   List<Ancestry> ancestries;
//   List<String> resonantArguments;
//   List<String> quirks;
//   List<GivenName> givenNames;
//   List<Surname> surnames;
//   List<ShopQuality> shopQualities;
//   List<ShopName> shopNames;

//   Map<String, int> myDemographics;

//   StateNotifierProvider<PeopleList, List<Person>> peopleListProvider;
//   StateNotifierProvider<ProviderList<LocationRole>, List<LocationRole>>
//   locationRoleListProvider;
//   StateNotifierProvider<ProviderList<PendingRoles>, List<PendingRoles>>
//   pendingRoleListProvider;

//   // StateNotifierProvider<ShopList,List<Shop>> shopListProvider;

//   StateNotifierProvider<RelationshipProvider, List<Node>> relationshipsProvider;

//   Box<String> peopleBox;
//   // Box<String> shopBox;
//   Box<String> locationBox;

//   Box<String> relationshipBox;
//   Box<String> locationRoleBox;
//   Box<String> peopleSearchBox;
//   Box<String> locationSearchBox;
//   Box<String> pendingRolesBox;

//   StateNotifierProvider<Trie, Map<String, Set<String>>> peopleSearch;
//   StateNotifierProvider<Trie, Map<String, Set<String>>> locationSearch;

//   String randomAncestry({Set<String>? restrictedAncestries}) {
//     Set<String> valid = restrictedAncestries ?? myDemographics.keys.toSet();
//     int maxPoints = 0;
//     for (final v in valid) {
//       maxPoints += myDemographics[v]!;
//     }
//     int r = maxPoints > 0 ? random.nextInt(maxPoints) : 0;
//     for (final v in valid) {
//       if (r < myDemographics[v]!) {
//         return v;
//       } else {
//         r -= myDemographics[v]!;
//       }
//     }
//     print("*************************** an outsider!");
//     return valid.toList()[random.nextInt(valid.length)];
//   }

//   StateNotifierProvider<LocationList, List<Location>> locationsListProvider;

//   Town({
//     required ref,
//     required this.peopleBox,
//     required this.ancestries,
//     required this.resonantArguments,
//     required this.quirks,
//     required this.givenNames,
//     required this.surnames,
//     required this.shopQualities,
//     required this.shopNames,
//     required this.locationBox,
//     required this.name,
//     required this.id,
//     required this.myDemographics,
//     required this.relationshipBox,
//     required this.locationRoleBox,
//     required this.locationSearchBox,
//     required this.peopleSearchBox,
//     required this.pendingRolesBox,
//   }) : peopleListProvider = StateNotifierProvider<PeopleList, List<Person>>((
//          ref,
//        ) {
//          final pbox = peopleBox;
//          return PeopleList(
//            peopleBox: pbox,
//            ancestries: ancestries,
//            resonantArguments: resonantArguments,
//            givenNames: givenNames,
//            surnames: surnames,
//            quirks: quirks,
//            initialPeople:
//                pbox.values
//                    .map((e) => Person.fromJson((e)))
//                    .cast<Person>()
//                    .toList(),
//          );
//        }),
//        locationsListProvider =
//            StateNotifierProvider<LocationList, List<Location>>((ref) {
//              return LocationList(myBox: locationBox);
//            }),
//        relationshipsProvider =
//            StateNotifierProvider<RelationshipProvider, List<Node>>((ref) {
//              return RelationshipProvider(
//                myBox: relationshipBox,
//                nodes:
//                    relationshipBox.values
//                        .map((v) => Node.fromJson(v))
//                        .cast<Node>()
//                        .toList(),
//              );
//            }),
//        locationRoleListProvider = StateNotifierProvider<
//          ProviderList<LocationRole>,
//          List<LocationRole>
//        >((ref) {
//          return ProviderList(
//            myBox: locationRoleBox,
//            fromJson: LocationRole.fromJson,
//          );
//        }),
//        pendingRoleListProvider = StateNotifierProvider<
//          ProviderList<PendingRoles>,
//          List<PendingRoles>
//        >((ref) {
//          return ProviderList(
//            myBox: pendingRolesBox,
//            fromJson: PendingRoles.fromJson,
//          );
//        }),
//        peopleSearch = StateNotifierProvider<Trie, Map<String, Set<String>>>((
//          ref,
//        ) {
//          return Trie(myBox: peopleSearchBox);
//        }),
//        locationSearch = StateNotifierProvider<Trie, Map<String, Set<String>>>((
//          ref,
//        ) {
//          return Trie(myBox: locationSearchBox);
//        });

//   Future<void> populateTown({
//     required Function(String) onMessageUpdate,
//     required String government,
//     required CitySize mySize,
//     required WidgetRef ref,
//   }) async {
//     String range = citySize2rangesOfNumPeople[mySize]!;
//     int minNum = int.parse(range.split("-").first);
//     int maxNum = int.parse(range.split("-").last);
//     int numPeople = minNum + random.nextInt(maxNum - minNum);

//     // GovernmentQuery gq = GovernmentQuery(government, mySize.toString());

//     final roleMetaPN = ref.watch(roleMetaProvider.notifier);
//     await roleMetaPN.initialize();

//     final shopNamesPN = ref.watch(shopNamesProvider.notifier);
//     await shopNamesPN.initialize();

//     final shopQualitiesPN = ref.watch(shopQualitiesProvider.notifier);
//     await shopQualitiesPN.initialize();

//     final genericServicesPN = ref.read(genericServicesProvider.notifier);
//     await genericServicesPN.initialize();

//     final specialtyServicesPN = ref.read(specialtyServicesProvider.notifier);
//     await specialtyServicesPN.initialize();

//     // final json = await rootBundle.loadString("./lib/initialization_files/roleGen.json");
//     // await roleMetaPN.loadFromJsonAndCommit(json);

//     // final json = await rootBundle.loadString("./lib/demofiles/all_shop_names.json");
//     // await shopNamesPN.loadFromJsonAndCommit(json);

//     // final json2 = await rootBundle.loadString("./lib/demofiles/all_qualities.json");
//     // await shopQualitiesPN.loadFromJsonAndCommit(json2);

//     // final json3 = await rootBundle.loadString("./lib/demofiles/service_generic.json");
//     // await genericServicesPN.loadFromJsonAndCommit(json3);

//     // final json4 = await rootBundle.loadString("./lib/demofiles/service_special.json");
//     // await specialtyServicesPN.loadFromJsonAndCommit(json4);

//     final resonantArgumentsPN = ref.watch(resonantArgumentsProvider.notifier);
//     await resonantArgumentsPN.initialize();

//     // final json2 = await rootBundle.loadString("./lib/demofiles/Demotown.resonantArgument");
//     // await resonantArgumentsPN.loadFromJsonAndCommit(json2);

//     final quirksPN = ref.watch(quirksProvider.notifier);
//     await quirksPN.initialize();

//     // final json3 = await rootBundle.loadString("./lib/demofiles/Demotown.quirks");
//     // await quirksPN.loadFromJsonAndCommit(json3);

//     final givenNamesPN = ref.watch(givenNamesProvider.notifier);
//     await givenNamesPN.initialize();

//     // final json4 = await rootBundle.loadString("./lib/demofiles/Demotown.givenNamesIndividualNEW");
//     // await givenNamesPN.loadFromJsonAndCommit(json4);

//     final surnamesPN = ref.watch(surnamesProvider.notifier);
//     await surnamesPN.initialize();

//     // final json5 = await rootBundle.loadString("./lib/demofiles/Demotown.surnamesIndividual");
//     // await surnamesPN.loadFromJsonAndCommit(json5);

//     final positions = ref.watch(positionsProvider);

//     final govRoles = getListOfRoles(mySize, government, ref);

//     // print("Hi");
//     List<GovHelper> govHelpers = [];
//     for (final gr in govRoles) {
//       final p = positions.firstWhereOrNull((p) => p.positionKey == gr);
//       if (p != null) {
//         govHelpers.add(
//           GovHelper(
//             age: p.getRandomAge()!,
//             position: gr,
//             createMethod: govCreateMethod(government, gr),
//             validRoles: govValidRoles(gr),
//           ),
//         );
//       } else {
//         final method = govCreateMethod(government, gr);
//         govHelpers.add(
//           GovHelper(
//             position: gr,
//             createMethod: method,
//             age: getRandomAgeNoPosition(government)!,
//             validRoles: getGovRolesNoPosition(government),
//           ),
//         );
//       }
//     }
//     // Add a timeout after which you'll proceed with default values

//     // final govRoles = await waitForDataAndGetRoles(ref, gq);

//     onMessageUpdate("Creating people...");
//     await createPeopleFS(numPeople, ref, govHelpers);
//     onMessageUpdate("Created people√  Establishing Social Networks...");

//     await createSocialNetworkFS(ref);
//     onMessageUpdate(
//       "Making & Adopting Children ${mySize.index >= CitySize.city.index ? "Takes a minute for cities and metropoli, sorry, lots of kids" : ""}...",
//     );

//     await makeChildren(ref.read(peopleProvider), ref);

//     onMessageUpdate("People are done, establishing them in their jobs...");

//     await setupMarketHirelings(ref);

//     onMessageUpdate("Creating stores, etc...");

//     List<LocationRole> cachedRoles = List.from(
//       ref.read(locationRoleListProvider),
//     );

//     final infoOnly = ref
//         .read(locationRolesProvider)
//         .where((cr) => cr.locationID == infoID);

//     for (final cr in infoOnly) {
//       switch (cr.myRole) {
//         case Role.smith:
//           await addRandomShopNoCommit(ShopType.smith, ref, cr.myID);
//           break;
//         case Role.tailor:
//           await addRandomShopNoCommit(ShopType.clothier, ref, cr.myID);
//           break;

//         case Role.herbalist:
//           await addRandomShopNoCommit(ShopType.herbalist, ref, cr.myID);
//           break;
//         case Role.jeweler:
//           await addRandomShopNoCommit(ShopType.jeweler, ref, cr.myID);
//           break;
//         case Role.generalStoreOwner:
//           await addRandomShopNoCommit(ShopType.generalStore, ref, cr.myID);
//           break;
//         case Role.magicShopOwner:
//           await addRandomShopNoCommit(ShopType.magic, ref, cr.myID);
//           break;
//         case Role.hierophant:
//           await addRandomShopNoCommit(ShopType.temple, ref, cr.myID);
//           break;
//         default:
//           break;
//       }
//     }

//     onMessageUpdate("Establishing taverns...");

//     for (final cr in cachedRoles) {
//       switch (cr.myRole) {
//         case Role.tavernKeeper:
//           await addRandomShopNoCommit(ShopType.tavern, ref, cr.myID);
//           break;
//         default:
//           break;
//       }
//     }

//     final locs = ref.read(locationsProvider);
//     await commitShops(ref);

//     // print(roles);

//     onMessageUpdate("All done!  Taking you there.");

//     // for(final t in ShopType.values){
//     //   Map<ShopType,int> numShopsMap=citySize2numShops[mySize]!;
//     //   int numShops = numShopsMap[t]!;
//     //   for (int i =0; i < numShops; i++)
//     //   {
//     //     await addRandomShop(t, ref);
//     //   }
//     // }
//     //
//     //  final test2 = ref.read(locationRoleListProvider).where((lr)=>lr.locationID==hirelingID).toList();

//     // print("All done");
//   }
// }

import 'package:flutter/services.dart';
// import "name_class_and_data.dart";
// import "package:uuid/uuid.dart";
// import "package:hive/hive.dart";
// import "dart:convert";
// import "enums_and_maps.dart";
// import "new_shops.dart";
// import "demographics.dart";
// import "services.dart";
// import "roles.dart";
// // import "service"


// final _uuid = Uuid();



// Future<void> initAllBoxes() async {
//   // Initialize givenNames box
//   await initHiveBoxFromJson(
//     boxName: "givenNameBox",
//     assetPath: "lib/demofiles/Demotown.givenNamesIndividual",
//     jsonToBoxData: givenNameBoxJson,
//   );
//   await initHiveBoxFromJson(
//     boxName: "surnameBox",
//     assetPath: "lib/demofiles/demotown.surnamesIndividual",
//     jsonToBoxData: surnameBoxJson,
//   );
//   await initHiveBoxFromJson(
//     boxName: "shopNameBox",
//     assetPath: './lib/demofiles/all_shop_names.json',
//     jsonToBoxData: shopNameBoxJson,
//   );
//   await initHiveBoxFromJson(
//     boxName: "shopQualityBox",
//     assetPath: './lib/demofiles/all_qualities.json',
//     jsonToBoxData: shopQualityBoxJson,
//   );
//   await initHiveBoxFromJson(
//     boxName: "ancestryBox",
//     assetPath: './lib/demofiles/demotown.demographics',
//     jsonToBoxData: ancestryBoxJson,
//   );
//   await initHiveBoxFromJson(
//     boxName: "resArgBox",
//     assetPath: './lib/demofiles/demotown.resonantArgument',
//     jsonToBoxData: resArgBoxJson,
//   );

//   await initHiveBoxFromJson(
//     boxName: "quirkBox",
//     assetPath: './lib/demofiles/demotown.quirks',
//     jsonToBoxData: quirkBoxJson,
//   );

//   await safeOpenBox(
//     boxName: "peopleSearchBox",
//   );

//   await safeOpenBox(
//     boxName: "locSearchBox",
//   );
//   await safeOpenBox(
//     boxName: "townBox",
//   );
//   await safeOpenBox(
//     boxName: "peopleBox",
//   );
//   await safeOpenBox(
//     boxName: "bigShopBox",
//   );
//   await safeOpenBox(
//     boxName: "relationshipBox",
//   );
//   await safeOpenBox(
//     boxName: "locationsRoleBox",
//   );
//   await safeOpenBox(
//     boxName: "locbox",
//   );
//   await safeOpenBox(
//     boxName: "pendingRolesBox",
//   );
//  await initHiveBoxFromJson(
//     boxName: "genericServiceBox",
//     assetPath: './lib/demofiles/service_generic.json',
//     jsonToBoxData: genericServicesBoxJson,
//   );
//   await initHiveBoxFromJson(
//     boxName: "specialtyBox",
//     assetPath: './lib/demofiles/service_special.json',
//     jsonToBoxData: specialtyServicesBoxJson,
//   );
//   await initHiveBoxFromJson(
//     boxName: "roleBox",
//     assetPath: './lib/initialization_files/roleGen.json',
//     jsonToBoxData: roleGenBoxJson,
//   );
//   //  await safeOpenBox(
//   //   boxName: "roleBox",
//   // );

//   // var roleBox = await  Hive.openBox<String>("roleBox");
// // await Hive.openBox<String>("relationshipBox");

// // Box peopleBox = await Hive.openBox<String>("peopleBox");


// // Box bsBox= await Hive.openBox<String>("bigShopBox");

// // Box relationshipBox=await Hive.openBox<String>("relationshipBox");
// // Box locationsRoleBox = await Hive.openBox<String>("locationsRoleBox");
// // Box locbox = await Hive.openBox<String>("locbox");
// // await Hive.openBox<String>("pendingRolesBox");
  




  
  

  
  
//   // Add more boxes as needed...
// }


// /// Generic function to initialize a Hive box with fallback to JSON asset
// /// 
// /// [boxName]: Name of the Hive box
// /// [assetPath]: Path to the JSON asset file (e.g. 'assets/givenNames.json')
// /// [jsonToBoxData]: Function that converts JSON data to box entries
// /// [validateEntry]: Optional function to validate an entry from the box
// Future<void> initHiveBoxFromJson({
//   required String boxName,
//   required String assetPath,
//   required Future<void> Function(Box<String> box, String jsonData) jsonToBoxData,
//   bool Function(String? data)? validateEntry,
// }) async {
//   // First, check if the box exists
//   bool boxExists = await Hive.boxExists(boxName);
  
//   // If the box exists and might be corrupted, delete it first
//   if (boxExists) {
//     try {
//       // Try to safely close the box if it's open
//       if (Hive.isBoxOpen(boxName)) {
//         await Hive.box(boxName).close();
//       }
//     } catch (e) {
//       print("Error closing box: $e");
//     }
    
//     try {
//       // Delete the potentially corrupted box
//       await Hive.deleteBoxFromDisk(boxName);
//       print("Deleted potentially corrupted box: $boxName");
//     } catch (e) {
//       print("Error deleting box: $e");
//     }
//   }

//   try {
//     // Create a fresh box
//     Box<String> box = await Hive.openBox<String>(boxName);
    
//     // Load from JSON
//     final String jsonString = await rootBundle.loadString(assetPath);
    
//     // Use the provided function to add entries to the box
//     await jsonToBoxData(box, jsonString);
//   } catch (e) {
//     print("Fatal error initializing box $boxName: $e");
//     // Re-throw or handle as needed
//     rethrow;
//   }
// }

// Future<Box<String>> safeOpenBox({
//   required String boxName,
// }) async {
//   try {
//     // Try to open the box normally first
//     return await Hive.openBox<String>(boxName);
//   } catch (e) {
//     print("Error opening box $boxName: $e");
    
//     // Box might be corrupted, try to safely close and delete it
//     try {
//       if (Hive.isBoxOpen(boxName)) {
//         await Hive.box(boxName).close();
//       }
//     } catch (closeError) {
//       print("Error closing box: $closeError");
//     }
    
//     try {
//       await Hive.deleteBoxFromDisk(boxName);
//       print("Deleted corrupted box: $boxName");
//     } catch (deleteError) {
//       print("Error deleting box: $deleteError");
//     }
    
//     // Create a fresh empty box
//     try {
//       return await Hive.openBox<String>(boxName);
//     } catch (reopenError) {
//       print("Fatal error reopening box $boxName: $reopenError");
//       rethrow;
//     }
//   }
// }



// Future<void> givenNameBoxJson(box,jsonData) async{
//       final xlist = json.decode(jsonData) as List;
//       for (int i = 0; i<xlist.length; i++)
//       {
//         var x = xlist[i];
//         GivenName me = GivenName(
//         name: x["name"],
//         id: _uuid.v4(),
//         ancestry: (x["ancestry"] as List<dynamic>)
//                                 .map((e) => e as String) // Explicitly cast each item to String?
//                                   .toList(),
//         pronouns: (x["pronouns"] as List<dynamic>)
//                                 .map((e) => string2Enum(e as String)).cast<PronounType>().toList());
                        

//         //  await gnBox.add(jsonEncode(me.toJson()));
//         await box.put(me.id, jsonEncode(me.toJson()));
//       }
// }

// Future<void> surnameBoxJson(box,jsonData) async{
//   final xlist = json.decode(jsonData) as List;
//   for (int i=0; i < xlist.length; i++)
//   {
//     var x= xlist[i];
//     Surname me = Surname(
//         ancestry: (x["ancestry"] as List<dynamic>)
//                               .map((e) => e as String) // Explicitly cast each item to String?
//                                  .toList(),
//         name: x["name"],
//         id: _uuid.v4());
//   //  await snBox.add(jsonEncode(me.toJson()));
//   await box.put(me.id, jsonEncode(me.toJson()));
//   }
// }

// Future<void> shopNameBoxJson(box,jsonData) async{
//   final xlist = json.decode(jsonData) as List;
//   for (int i=0; i < xlist.length; i++)
//   {
//     var x = xlist[i];
//     ShopName me = ShopName(
//       word: x["word"],
//       id: _uuid.v4(),
//       shopType: ShopType.values.firstWhere((t)=>t.name == x["shopType"]),
//       wordType: WordType.values.firstWhere((t)=>t.name==x["wordType"]));
//     // await shopNameBox.add(jsonEncode(me.toJson()));
//     await box.put(me.id, jsonEncode(me.toJson()));
//   }
// }

// Future<void> shopQualityBoxJson(box,jsonData) async{
//   final xlist = json.decode(jsonData) as List;
//   for (int i=0; i < xlist.length; i++)
//   {
//     var x = xlist[i];
//     ShopQuality me = ShopQuality(
//       pro: x["pro"],
//       con: x["con"],
//       type: ShopType.values.firstWhere((v)=>v.name==(x["type"])),
//       id: _uuid.v4());
//       await box.put(me.id, jsonEncode(me.toJson()));
//   }
// }


// Future<void> ancestryBoxJson(box,jsonData) async{
//   final xlist = json.decode(jsonData) as List;
//   for (int i = 0; i<xlist.length; i++)
//   {
//     var x = xlist[i];
//     Ancestry me=Ancestry(name: x["name"],
//                          id: x["id"].toString(),
//                          adoptionWithinProb:  (x["adoptionWithinProb"]),
//                          adoptionOutsideProb:  (x["adoptionOutsideProb"]),
//                          quiteYoungProb:  (x["quiteYoungProb"]),
//                          youngProb:  (x["youngProb"]),
//                          adultProb:  (x["adultProb"]),
//                          middleAgeProb:  (x["middleAgeProb"]),
//                          oldProb:  (x["oldProb"]),
//                          quiteOldProb:  (x["quiteOldProb"]),
//                          heHimProb:  (x["heHimProb"]),
//                          sheHerProb:  (x["sheHerProb"]),
//                          theyThemProb:  (x["theyThemProb"]),
//                          heTheyProb:  (x["heTheyProb"]),
//                          sheTheyProb:  (x["sheTheyProb"]),

//                          partnerWithinProb:  (x["partnerWithinProb"]),
//                          partnerOutsideProb:  (x["partnerOutsideProb"]),
//                          breakupProb:  (x["breakupProb"]),
//                          noChildrenProb:  (x["noChildrenProb"]),
//                           childrenProb:  (x["childrenProb"]),
//                         maxChildren: (x["maxChildren"]),
//                         straightProb:  (x["straightProb"]),
//                         queerProb:  (x["queerProb"]),
//                         ifPolyFliptoQueerProb:  (x["ifPolyFliptoQueerProb"]),
//                         maxPolyPartner: (x["maxPolyPartner"]),
//                         polyProb:  (x["polyProb"]),
//                         );
//   //  await aBox.add(jsonEncode(me.toJson()));
//    await box.put(me.id, jsonEncode(me.toJson()));
//   }
// }

// Future<void> resArgBoxJson(box,jsonData) async{
// final xlist = json.decode(jsonData) as List;
// for (int i = 0; i<xlist.length; i++)
//   {
//     var x = xlist[i];
//     await box.add(x["argument"]);
//   }
// }

// Future<void> quirkBoxJson(box,jsonData) async{
//   final xlist = json.decode(jsonData) as List;
//   for (int i=0; i < xlist.length; i++)
//   {
//     var x = xlist[i];
//     await box.add(x["quirk"]);
//   }
// }

// Future<void> genericServicesBoxJson(box,jsonData) async{
//   final xlist = json.decode(jsonData) as List;
//   for (int i=0; i < xlist.length; i++)
//   {
//     var x = xlist[i];
//     GenericService me = GenericService.fromJson(x);
//     // print("hi");
//     await box.put(me.compositeKey(), jsonEncode(me.toJson()));
//   }
// }

// Future<void> specialtyServicesBoxJson(box,jsonData) async{
//   final xlist = json.decode(jsonData) as List;
//   for (int i=0; i < xlist.length; i++)
//   {
//     var x = xlist[i];
//     Specialty me = Specialty.fromJson(x);
//     await box.put(me.compositeKey(), jsonEncode(me.toJson()));
//   }
// }

// Future<void> roleGenBoxJson(box,jsonData) async{
//   final xlist = json.decode(jsonData) as List;
//   for (int i=0; i < xlist.length; i++)
//   {
//     var x = xlist[i];
//     RoleGeneration me = RoleGeneration.fromJson(x);
//     await box.put(me.compositeKey(), jsonEncode(me.toJson()));
//   }
// }

// import "dart:convert";
// import 'package:flutter/services.dart';
// import 'package:hooks_riverpod/hooks_riverpod.dart';
// import "package:firetown/providers.dart";
// import 'load_json.dart';
// import 'new_shops.dart';
// import "enums_and_maps.dart";
// import "package:uuid/uuid.dart";
// import "services.dart";

// import "package:hive_flutter/hive_flutter.dart";

// const _uuid = Uuid();

// // Future<void> makeBoxforRoleGeneration(WidgetRef ref) async {
// //   String roleGenJson;
// //   try {
// //     roleGenJson =
// //         await rootBundle.loadString('./lib/initialization_files/roleGen.json');
// //   } catch (e) {
// //     throw ("Error loading JSON: $e");
// //   }

// //   var x =
// //       (jsonDecode(roleGenJson) as List).cast<Map<String, dynamic>>().toList();
// //   await ref
// //       .read(ref.read(myWorldProvider).allRoles.notifier)
// //       .overwriteFromJson(x);
// // }

// Future<void> makeBoxForShopGeneration(WidgetRef ref) async {
//   try {
//     shopNameJson =
//         await rootBundle.loadString('./lib/demofiles/all_shop_names.json');
//   } catch (e) {
//     throw ("Error loading JSON: $e");
//   }
//   try {
//     shopQualitiesJson =
//         await rootBundle.loadString('./lib/demofiles/all_qualities.json');
//   } catch (e) {
//     throw ("Error loading JSON: $e");
//   }

//   Box shopNameBox = Hive.box<String>('shopNameBox');
//   await shopNameBox.clear();
//   var xlist = json.decode(shopNameJson) as List;
//   for (int i = 0; i < xlist.length; i++) {
//     var x = xlist[i];
//     ShopName me = ShopName(
//         word: x["word"],
//         id: _uuid.v4(),
//         shopType: string2Enum(x["shopType"]),
//         wordType: string2Enum(x["wordType"]));
//     // await shopNameBox.add(jsonEncode(me.toJson()));
//     await shopNameBox.put(me.id, jsonEncode(me.toJson()));
//   }

//   Box sqBox = Hive.box<String>('shopQualityBox');
//   await sqBox.clear();
//   xlist = json.decode(shopQualitiesJson) as List;
//   for (int i = 0; i < xlist.length; i++) {
//     var x = xlist[i];
//     ShopQuality me = ShopQuality(
//         pro: x["pro"],
//         con: x["con"],
//         type: ShopType.values.firstWhere((v) => v.name == (x["type"])),
//         id: _uuid.v4());
//     await sqBox.put(me.id, jsonEncode(me.toJson()));
//   }

//   String serviceGenericJson = "";
//   try {
//     serviceGenericJson =
//         await rootBundle.loadString('./lib/demofiles/service_generic.json');
//   } catch (e) {
//     throw ("Error loading JSON: $e");
//   }
//   Box worldServiceGenericBox = Hive.box<String>("genericServiceBox");
//   await worldServiceGenericBox.clear();

//   xlist = json.decode(serviceGenericJson) as List;
//   for (int i = 0; i < xlist.length; i++) {
//     var x = xlist[i];
//     GenericService me = GenericService.fromJson(x);
//     // print("hi");
//     await worldServiceGenericBox.put(me.id, jsonEncode(me.toJson()));
//   }

//   String serviceSpecialtyJson = "";
//   try {
//     serviceSpecialtyJson =
//         await rootBundle.loadString('./lib/demofiles/service_special.json');
//   } catch (e) {
//     throw ("Error loading JSON: $e");
//   }
//   Box worldServiceSpecialBox = Hive.box<String>("specialtyBox");
//   await worldServiceSpecialBox.clear();

//   xlist = json.decode(serviceSpecialtyJson) as List;
//   for (int i = 0; i < xlist.length; i++) {
//     var x = xlist[i];
//     Specialty me = Specialty.fromJson(x);
//     await worldServiceSpecialBox.put(me.id, jsonEncode(me.toJson()));
//   }
// }


void add2Box(Box box, String key, dynamic value) {
//   final list = (box.get(key) ?? []) as List<dynamic>; // Retrieve the list or create an empty one
//   list.add(value); // Add the value to the list
//   box.put(key, list); // Persist the updated list back to the box
// }

// // List<int> indicesWhere<T>(List<dynamic> list, bool Function(dynamic element) condition) {
//   List<int> indices = [];
//   for (int i = 0; i < list.length; i++) {
//     if (condition(list[i])) {
//       indices.add(i);
//     }
//   }
//   return indices;
// }


// extension PendingRolesProviderList on ProviderList<PendingRoles> {
//   Future<void> removeFromRole(Role role, int numToRemove) async {
//     if (numToRemove <= 0) {
//       throw ArgumentError('numToRemove must be positive');
//     }
    
//     try {
//       // Use a more direct lookup approach if possible
//       // If you can use role as a key or have a mapping, that would be better
//       PendingRoles? targetPendingRole;
      
//       // Get current state to avoid duplicate deserialization
//       final currentItems = getState();
      
//       for (int i = 0; i < currentItems.length; i++) {
//         if (currentItems[i].role == role) {
//           targetPendingRole = currentItems[i];
//           break;
//         }
//       }
      
//       if (targetPendingRole != null) {
//         final newCount = targetPendingRole.howMany - numToRemove;
        
//         if (newCount <= 0) {
//           await deleteWithoutStateUpdate(targetPendingRole.compositeKey());
//           // Create new state by removing the item
//           final newState = List<PendingRoles>.from(currentItems);
//           newState.removeWhere((item) => item.role == role);
//           setState(newState);
//         } else {
//           final updatedPendingRole = PendingRoles(
//             howMany: newCount,
//             role: role
//           );
          
//           await replaceWithoutStateUpdate(targetPendingRole.compositeKey(), updatedPendingRole);
          
//           // Update just the changed item in state
//           final newState = List<PendingRoles>.from(currentItems);
//           final index = newState.indexWhere((item) => item.role == role);
//           if (index != -1) {
//             newState[index] = updatedPendingRole;
//           }
//           setState(newState);
//         }
//       }
//     } catch (e) {
//       // Log error and potentially rethrow or handle appropriately
//       print('Error removing from role: $e');
//       rethrow;
//     }
//   }
  
//   // Helper methods that don't update state
  

// }





// class ProviderListFireStore<T extends JsonSerializable> extends StateNotifier<List<T>>
// {
//   final T Function(Map<String,dynamic>) fromJson;
//   ListType myList;

//  ProviderListFireStore({required this.myList, required initList, required this.fromJson})
//       : super(initList);
    
//   void addNoSync({required T addMe}) {
//     state = [...state, addMe];
//   }

//   String _convertToString(){
//     return jsonEncode(state.map((s)=>(s as dynamic).toJson()).toList());
//   }
//   void _stateFromString(String s) {
//     final decodedJson = jsonDecode(s) as List<dynamic>;
//     state = decodedJson.map((j) => fromJson(j as Map<String, dynamic>)).toList().cast<T>();
//   }

//   Future<void> sendToFireBase(ref) async {
//     final fSP = ref.read(firestoreServiceProvider);
//       await fSP.putDocString(this.myList, _convertToString(),ref);
//   }

//   Future<void> stateFromFireBase(ref) async {
//     final fSP = ref.read(firestoreServiceProvider);
//     String? s= await fSP.getDocString(this.myList,ref).first;
//     if(s == null){state = [];}
//     else{ _stateFromString(s);}
//   }



//   Future<void> bulkAddThenSync({required List<T> items, required ref}) async {
//       for (int i = 0; i < items.length; i++) {
//         final item = items[i];
//         addNoSync(addMe: item);
//       }
//       sendToFireBase(ref);
//   }

//   Future<void> deleteAndSync(T deleteWho, ref) async{
//     try{
//       state.removeWhere((s)=>s.compositeKey() == deleteWho.compositeKey());
//       sendToFireBase(ref);
//     } catch (e){
//       debugPrint("Error deleting ${deleteWho.compositeKey}");
//     }
//   }

  
//   Future<void> replaceAndSync(T replaceWho, T newValue, ref) async {
//     try{
//       int i = state.indexWhere((s)=>s.compositeKey() == replaceWho.compositeKey());
//       state[i] = newValue;
//       sendToFireBase(ref);
//     } catch (e){
//       print("Error replacing ${replaceWho.compositeKey}");
//     }
//   }

//   List<T> get items => state;
  
//   void setState(List<T> newState) => state = newState;
// }

// // Add this to your ProviderList class
// // extension PendingRolesProviderList on ProviderList<PendingRoles> {
// //   Future<void> removeFromRole(Role role, int numToRemove) async {
// //     if (numToRemove <= 0) {
// //       throw ArgumentError('numToRemove must be positive');
// //     }
    
// //     try {
// //       // Use a more direct lookup approach if possible
// //       // If you can use role as a key or have a mapping, that would be better
// //       PendingRoles? targetPendingRole;
      
// //       // Get current state to avoid duplicate deserialization
// //       final currentItems = getState();
      
// //       for (int i = 0; i < currentItems.length; i++) {
// //         if (currentItems[i].role == role) {
// //           targetPendingRole = currentItems[i];
// //           break;
// //         }
// //       }
      
// //       if (targetPendingRole != null) {
// //         final newCount = targetPendingRole.howMany - numToRemove;
        
// //         if (newCount <= 0) {
// //           await deleteWithoutStateUpdate(targetPendingRole.compositeKey());
// //           // Create new state by removing the item
// //           final newState = List<PendingRoles>.from(currentItems);
// //           newState.removeWhere((item) => item.role == role);
// //           setState(newState);
// //         } else {
// //           final updatedPendingRole = PendingRoles(
// //             howMany: newCount,
// //             role: role
// //           );
          
// //           await replaceWithoutStateUpdate(targetPendingRole.compositeKey(), updatedPendingRole);
          
// //           // Update just the changed item in state
// //           final newState = List<PendingRoles>.from(currentItems);
// //           final index = newState.indexWhere((item) => item.role == role);
// //           if (index != -1) {
// //             newState[index] = updatedPendingRole;
// //           }
// //           setState(newState);
// //         }
// //       }
// //     } catch (e) {
// //       // Log error and potentially rethrow or handle appropriately
// //       print('Error removing from role: $e');
// //       rethrow;
// //     }
// //   }
  
// //   // Helper methods that don't update state
  

// // }



import 'package:flutter/services.dart';
// import 'package:flutter/material.dart';
// import 'dart:convert';
// import 'new_shops.dart';
// import 'package:hive/hive.dart';
// import "enums_and_maps.dart";
// import "person.dart";
// import "models/ancestry_model.dart";
// import "package:uuid/uuid.dart";
// import "roles.dart";
// import "name_class_and_data.dart";
// const _uuid = Uuid();

// String shopsJson ="";
// String peopleJson="";
// String tavernsJson="";
// String ancestriesJson="";
// String givenNamesJson="";
// String surnamesJson="";
// String quirksJson="";
// String raJson="";
// String shopNameJson="";
// String shopQualitiesJson="";
// Future<void> resetAllBoxes() async{
  
// }
//  Future<void> resetFromOldJSON() async {
//   WidgetsFlutterBinding.ensureInitialized();
//    try {
//     shopsJson = await rootBundle.loadString('./lib/demofiles/finalShops.json');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//   try {
//     peopleJson = await rootBundle.loadString('./lib/demofiles/finalPeeps.json');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//   try {
//     tavernsJson = await rootBundle.loadString('./lib/demofiles/finalTaverns.json');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//   try {
//     ancestriesJson = await rootBundle.loadString('./lib/demofiles/demotown.demographics');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//   try {
//     givenNamesJson = await rootBundle.loadString('./lib/demofiles/demotown.givenNamesIndividual');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//   try {
//     surnamesJson = await rootBundle.loadString('./lib/demofiles/demotown.surnamesIndividual');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//     try {
//     quirksJson = await rootBundle.loadString('./lib/demofiles/demotown.quirks');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//     try {
//     raJson = await rootBundle.loadString('./lib/demofiles/demotown.resonantArgument');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//       try {
//     shopNameJson = await rootBundle.loadString('./lib/demofiles/all_shop_names.json');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//     try {
//     shopQualitiesJson = await rootBundle.loadString('./lib/demofiles/all_qualities.json');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }


//   var xlist = json.decode(peopleJson) as List;
//   List<Person> myPeople=[];
//   for(int i=0; i< xlist.length;i++)
//   {
//     var x = xlist[i];

//       List<Relationship> myR=[];
//       for(int j=0; j<x["PartnerID"].length; j++)
//       {
//         myR.add(Relationship(myID: x["PartnerID"][j], myType:  RelationshipType.partner));
//       }
//       for(int j=0; j<x["ChildrenID"].length; j++)
//       {
//         myR.add(Relationship(myID: x["ChildrenID"][j], myType:  RelationshipType.child));
//       }
//       for(int j=0; j<x["ExIDs"].length; j++)
//       {
//         myR.add(Relationship(myID: x["ExIDs"][j], myType:  RelationshipType.ex));
//       }
//       for(int j=0; j<x["Parents"].length; j++)
//       {
//         myR.add(Relationship(myID: x["Parents"][j], myType:  RelationshipType.parent));
//       }
//       Person me=Person(firstName: x["FirstName"],
//                      surname: x["Surname"],
//                      ancestry: x["Ancestry"],
//                      pronouns: string2Enum(x["Pronouns"]),
//                      orientation: string2Enum(x["Orientation"]),
//                      age: string2Enum(x["Age"]),
//                      poly: string2Enum(x["Poly"]),
//                      quirk1: x["Quirk1"],
//                      quirk2: x["Quirk2"],
//                      resonantArgument: x["ResonantArgument"],
//                      faction: x["Faction"],
//                      id: x["ID"],
//                      partnerID: (x["PartnerID"] as List<dynamic>)
//                               .map((e) => e as String?) // Explicitly cast each item to String?
//                                  .toList(),
//                      childrenID: (x["ChildrenID"] as List<dynamic>)
//                               .map((e) => e as String?) // Explicitly cast each item to String?
//                                  .toList(),
//                      exIDs: (x["ExIDs"] as List<dynamic>)
//                               .map((e) => e as String?) // Explicitly cast each item to String?
//                                  .toList(),
//                      parents: (x["Parents"] as List<dynamic>)
//                               .map((e) => e as String?) // Explicitly cast each item to String?
//                                  .toList(),
//                      myRoles: List<LocationRole>.empty(growable: true),
//                      relationships: myR);
//       myPeople.add(me);
//   }

//   Box aBox=Hive.box<String>('ancestryBox');
//   await aBox.clear();
//   xlist = json.decode(ancestriesJson) as List;
//   for (int i = 0; i<xlist.length; i++)
//   {
//     var x = xlist[i];
//     Ancestry me=Ancestry(name: x["name"],
//                          id: x["id"].toString(),
//                          adoptionWithinProb:  (x["adoptionWithinProb"]),
//                          adoptionOutsideProb:  (x["adoptionOutsideProb"]),
//                          quiteYoungProb:  (x["quiteYoungProb"]),
//                          youngProb:  (x["youngProb"]),
//                          adultProb:  (x["adultProb"]),
//                          middleAgeProb:  (x["middleAgeProb"]),
//                          oldProb:  (x["oldProb"]),
//                          quiteOldProb:  (x["quiteOldProb"]),
//                          heHimProb:  (x["heHimProb"]),
//                          sheHerProb:  (x["sheHerProb"]),
//                          theyThemProb:  (x["theyThemProb"]),
//                          heTheyProb:  (x["heTheyProb"]),
//                          sheTheyProb:  (x["sheTheyProb"]),

//                          partnerWithinProb:  (x["partnerWithinProb"]),
//                          partnerOutsideProb:  (x["partnerOutsideProb"]),
//                          breakupProb:  (x["breakupProb"]),
//                          noChildrenProb:  (x["noChildrenProb"]),
//                           childrenProb:  (x["childrenProb"]),
//                         maxChildren: (x["maxChildren"]),
//                         straightProb:  (x["straightProb"]),
//                         queerProb:  (x["queerProb"]),
//                         ifPolyFliptoQueerProb:  (x["ifPolyFliptoQueerProb"]),
//                         maxPolyPartner: (x["maxPolyPartner"]),
//                         polyProb:  (x["polyProb"]),
//                         );
//   //  await aBox.add(jsonEncode(me.toJson()));
//    await aBox.put(me.id, jsonEncode(me.toJson()));
//   }
// Box raBox = Hive.box<String>('resArgBox');
// await raBox.clear();
// xlist = json.decode(raJson) as List;
// for (int i = 0; i<xlist.length; i++)
//   {
//     var x = xlist[i];
//     await raBox.add(x["argument"]);
//   }




// Box gnBox= Hive.box<String>('givenNameBox');
// await gnBox.clear();
// xlist = json.decode(givenNamesJson) as List;
// for (int i = 0; i<xlist.length; i++)
//   {
//     var x = xlist[i];
//     GivenName me = GivenName(
//       name: x["name"],
//       id: _uuid.v4(),
//       ancestry: (x["ancestry"] as List<dynamic>)
//                               .map((e) => e as String) // Explicitly cast each item to String?
//                                  .toList(),
//       pronouns: (x["pronouns"] as List<dynamic>)
//                               .map((e) => string2Enum(e as String)).cast<PronounType>().toList());
                      

//   //  await gnBox.add(jsonEncode(me.toJson()));
//    await gnBox.put(me.id, jsonEncode(me.toJson()));
//   }

  
  
//   Box snBox= Hive.box<String>('surnameBox');
//   await snBox.clear();
//   xlist = json.decode(surnamesJson) as List;
//   for (int i=0; i < xlist.length; i++)
//   {
//     var x= xlist[i];
//     Surname me = Surname(
//         ancestry: (x["ancestry"] as List<dynamic>)
//                               .map((e) => e as String) // Explicitly cast each item to String?
//                                  .toList(),
//         name: x["name"],
//         id: _uuid.v4());
//   //  await snBox.add(jsonEncode(me.toJson()));
//   await snBox.put(me.id, jsonEncode(me.toJson()));
//   }

// // var whatEndedUpinBox=snBox.values.map((e)=>Surname.fromJson(e)).cast<Surname>().toList();

// Box qBox= Hive.box<String>('quirkBox');
// await qBox.clear();
// xlist = json.decode(quirksJson) as List;
// for (int i=0; i < xlist.length; i++)
// {
//   var x = xlist[i];
//   await qBox.add(x["quirk"]);
// }
// // var whatEndedUpinBox=qBox.values.toList();

// Box shopNameBox=Hive.box<String>('shopNameBox');
// await shopNameBox.clear();
// xlist = json.decode(shopNameJson) as List;
// for (int i=0; i < xlist.length; i++)
// {
//   var x = xlist[i];
//   ShopName me = ShopName(
//     word: x["word"],
//     id: _uuid.v4(),
//     shopType: string2Enum(x["shopType"]),
//     wordType: string2Enum(x["wordType"]));
//   // await shopNameBox.add(jsonEncode(me.toJson()));
//   await shopNameBox.put(me.id, jsonEncode(me.toJson()));
// }

// // var whatEndedUpinBox=shopNameBox.values.map((e)=>ShopName.fromJson(e)).cast<ShopName>().toList();

// Box sqBox = Hive.box<String>('shopQualityBox');
// await sqBox.clear();
// xlist = json.decode(shopQualitiesJson) as List;
// for (int i=0; i < xlist.length; i++)
// {
//   var x = xlist[i];
//   ShopQuality me = ShopQuality(
//     pro: x["pro"],
//     con: x["con"],
//     type: string2Enum(x["type"]),
//     id: _uuid.v4());
//     await sqBox.put(me.id, jsonEncode(me.toJson()));
// }

// // var whatEndedUpinBox=sqBox.values.map((e)=>ShopQuality.fromJson(e)).cast<ShopQuality>().toList();

//   Box bigShopBox=Hive.box<String>("bigShopBox");
//   await bigShopBox.clear();
//   // var isItClear=bigShopBox.values.map((e)=>Shop.fromJson(e)).cast<Shop>().toList();
//   xlist = json.decode(shopsJson) as List;
  
//   for(int i=0; i<xlist.length; i++){
//         var x = xlist[i];
//         Shop me=Shop(con: x["Con"], pro1: x["Pro1"], pro2: x["Pro2"], name: x["Name"], shopType: string2Enum(x["Type"]),
//         id: x["ID"]);
//         await bigShopBox.put(me.id, (jsonEncode(me.toJson())));
//         // await bigShopBox.add((jsonEncode(me.toJson())));
//         switch(me.shopType)
//         {
          
//           case(ShopType.tavern):
//           for(int j = 0; j< x["OwnerID"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["OwnerID"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID: p.id, locationID: me.id, myRole: Role.owner, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["WaitStaff"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["WaitStaff"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.waitstaff, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["Cooks"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Cooks"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id, locationID: me.id, myRole: Role.cook, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["Entertainers"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Entertainers"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.entertainment, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["Regulars"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Regulars"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.regular, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//             break;
//           case(ShopType.clothier):
//           case(ShopType.herbalist):
//           case(ShopType.jeweler):
//           case(ShopType.smith):
//           default:
//           for(int j = 0; j< x["Apprentices"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Apprentices"][j]);
//             if(yourIndex!=-1)
//             {
//               Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.apprentice, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
              
              
//             }
//           }
//           for(int j = 0; j< x["Journeymen"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Journeymen"][j]);
//             if(yourIndex!=-1)
//             {
//               Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.journeyman, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["OwnerID"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["OwnerID"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.owner, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
        
//       }
//   }
  
//   xlist = json.decode(tavernsJson) as List;
  
//   for(int i=0; i<xlist.length; i++){
//         var x = xlist[i];
//         Shop me=Shop(con: x["Con"], pro1: x["Pro1"], pro2: x["Pro2"], name: x["Name"], shopType: string2Enum(x["Type"]),
//         id: x["ID"]);
//         await bigShopBox.put(me.id, (jsonEncode(me.toJson())));
//         // await bigShopBox.add((jsonEncode(me.toJson())));
//         // var whatsGoingOn = bigShopBox.values.map((e)=>Shop.fromJson(e)).cast<Shop>().toList();
//         switch(me.shopType)
//         {
          
//           case(ShopType.tavern):
//           for(int j = 0; j< x["OwnerID"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["OwnerID"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.owner, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["WaitStaff"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["WaitStaff"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.waitstaff, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["Cooks"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Cooks"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.cook, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["Entertainers"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Entertainers"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.entertainment, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["Regulars"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Regulars"][j]);
//             if(yourIndex!=-1)
//             {
//                             Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.regular, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//             break;
//           case(ShopType.clothier):
//           case(ShopType.herbalist):
//           case(ShopType.jeweler):
//           case(ShopType.smith):
//           default:
//           for(int j = 0; j< x["Apprentices"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Apprentices"][j]);
//             if(yourIndex!=-1)
//             {
//               Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.apprentice, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
              
              
//             }
//           }
//           for(int j = 0; j< x["Journeymen"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["Journeymen"][j]);
//             if(yourIndex!=-1)
//             {
//               Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.journeyman, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
//           for(int j = 0; j< x["OwnerID"].length; j++)
//           {
//             int yourIndex=myPeople.indexWhere((element) => element.id==x["OwnerID"][j]);
//             if(yourIndex!=-1)
//             {
//              Person p=myPeople[yourIndex];
//               LocationRole lr=LocationRole(myID:p.id,locationID: me.id, myRole: Role.owner, specialty: "");
//               myPeople[yourIndex] = Person(firstName: p.firstName,
//                                   surname: p.surname,
//                                   ancestry: p.ancestry,
//                                   pronouns: p.pronouns,
//                                   orientation: p.orientation,
//                                   age: p.age,
//                                   poly: p.poly,
//                                   quirk1: p.quirk1,
//                                   quirk2: p.quirk2,
//                                   resonantArgument: p.resonantArgument,
//                                   faction: p.faction,
//                                   id: p.id,
//                                   partnerID: p.partnerID,
//                                   childrenID: p.childrenID,
//                                   exIDs: p.exIDs,
//                                   parents: p.parents,
//                                   myRoles: p.myRoles..add(lr),
//                                   relationships: p.relationships,
//                                   );
//             }
//           }
        
//       }
//   }
  
//   Box peopleBox=Hive.box<String>("peopleBox");
//   await peopleBox.clear();
//   for(int i=0; i<myPeople.length; i++)
//   {
//     await peopleBox.put(myPeople[i].id, jsonEncode(myPeople[i].toJson()));
//   }
//   Box relationshipBox=Hive.box<String>("relationshipBox");
//   await relationshipBox.clear();
//   // myPeople.map((p)=>peopleBox.add(jsonEncode(p.toJson())));
//   // var whatEndedUpinBox=peopleBox.values.map((e)=>Person.fromJson(e)).cast<Person>().toList();
//   // bigShopBox=bigShopBox;
//   // var whatEndedUpinBigShopBox=bigShopBox.values.map((e)=>Shop.fromJson(e)).cast<Shop>().toList();
//   // print ("Halt and catch fire");
// }
  

// Future<void> freshTownFromJSON() async {
//   WidgetsFlutterBinding.ensureInitialized();

// Box peopleBox=Hive.box<String>("peopleBox");
//   await peopleBox.clear();

//   Box bigShopBox=Hive.box<String>("bigShopBox");
//   await bigShopBox.clear();

//   try {
//     ancestriesJson = await rootBundle.loadString('./lib/demofiles/demotown.demographics');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//   try {
//     givenNamesJson = await rootBundle.loadString('./lib/demofiles/demotown.givenNamesIndividual');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//   try {
//     surnamesJson = await rootBundle.loadString('./lib/demofiles/demotown.surnamesIndividual');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//     try {
//     quirksJson = await rootBundle.loadString('./lib/demofiles/demotown.quirks');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//     try {
//     raJson = await rootBundle.loadString('./lib/demofiles/demotown.resonantArgument');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//       try {
//     shopNameJson = await rootBundle.loadString('./lib/demofiles/all_shop_names.json');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//     try {
//     shopQualitiesJson = await rootBundle.loadString('./lib/demofiles/all_qualities.json');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }

//   Box aBox=Hive.box<String>('ancestryBox');
//   await aBox.clear();
//   var xlist = json.decode(ancestriesJson) as List;
//   for (int i = 0; i<xlist.length; i++)
//   {
//     var x = xlist[i];
//     Ancestry me=Ancestry(name: x["name"],
//                          id: x["id"].toString(),
//                          adoptionWithinProb:  (x["adoptionWithinProb"]),
//                          adoptionOutsideProb:  (x["adoptionOutsideProb"]),
//                          quiteYoungProb:  (x["quiteYoungProb"]),
//                          youngProb:  (x["youngProb"]),
//                          adultProb:  (x["adultProb"]),
//                          middleAgeProb:  (x["middleAgeProb"]),
//                          oldProb:  (x["oldProb"]),
//                          quiteOldProb:  (x["quiteOldProb"]),
//                          heHimProb:  (x["heHimProb"]),
//                          sheHerProb:  (x["sheHerProb"]),
//                          theyThemProb:  (x["theyThemProb"]),
//                          heTheyProb:  (x["heTheyProb"]),
//                          sheTheyProb:  (x["sheTheyProb"]),

//                          partnerWithinProb:  (x["partnerWithinProb"]),
//                          partnerOutsideProb:  (x["partnerOutsideProb"]),
//                          breakupProb:  (x["breakupProb"]),
//                          noChildrenProb:  (x["noChildrenProb"]),
//                           childrenProb:  (x["childrenProb"]),
//                         maxChildren: (x["maxChildren"]),
//                         straightProb:  (x["straightProb"]),
//                         queerProb:  (x["queerProb"]),
//                         ifPolyFliptoQueerProb:  (x["ifPolyFliptoQueerProb"]),
//                         maxPolyPartner: (x["maxPolyPartner"]),
//                         polyProb:  (x["polyProb"]),
//                         );
//   //  await aBox.add(jsonEncode(me.toJson()));
//    await aBox.put(me.id, jsonEncode(me.toJson()));
//   }
// Box raBox = Hive.box<String>('resArgBox');
// await raBox.clear();
// xlist = json.decode(raJson) as List;
// for (int i = 0; i<xlist.length; i++)
//   {
//     var x = xlist[i];
//     await raBox.add(x["argument"]);
//   }




// Box gnBox= Hive.box<String>('givenNameBox');
// await gnBox.clear();
// xlist = json.decode(givenNamesJson) as List;
// for (int i = 0; i<xlist.length; i++)
//   {
//     var x = xlist[i];
//     GivenName me = GivenName(
//       name: x["name"],
//       id: _uuid.v4(),
//       ancestry: (x["ancestry"] as List<dynamic>)
//                               .map((e) => e as String) // Explicitly cast each item to String?
//                                  .toList(),
//       pronouns: (x["pronouns"] as List<dynamic>)
//                               .map((e) => string2Enum(e as String)).cast<PronounType>().toList());
                      

//   //  await gnBox.add(jsonEncode(me.toJson()));
//    await gnBox.put(me.id, jsonEncode(me.toJson()));
//   }

  
  
//   Box snBox= Hive.box<String>('surnameBox');
//   await snBox.clear();
//   xlist = json.decode(surnamesJson) as List;
//   for (int i=0; i < xlist.length; i++)
//   {
//     var x= xlist[i];
//     Surname me = Surname(
//         ancestry: (x["ancestry"] as List<dynamic>)
//                               .map((e) => e as String) // Explicitly cast each item to String?
//                                  .toList(),
//         name: x["name"],
//         id: _uuid.v4());
//   //  await snBox.add(jsonEncode(me.toJson()));
//   await snBox.put(me.id, jsonEncode(me.toJson()));
//   }

// // var whatEndedUpinBox=snBox.values.map((e)=>Surname.fromJson(e)).cast<Surname>().toList();

// Box qBox= Hive.box<String>('quirkBox');
// await qBox.clear();
// xlist = json.decode(quirksJson) as List;
// for (int i=0; i < xlist.length; i++)
// {
//   var x = xlist[i];
//   await qBox.add(x["quirk"]);
// }
// // var whatEndedUpinBox=qBox.values.toList();

// // var whatEndedUpinBox=shopNameBox.values.map((e)=>ShopName.fromJson(e)).cast<ShopName>().toList();

// Box sqBox = Hive.box<String>('shopQualityBox');
// await sqBox.clear();
// xlist = json.decode(shopQualitiesJson) as List;
// for (int i=0; i < xlist.length; i++)
// {
//   var x = xlist[i];
//   ShopQuality me = ShopQuality(
//     pro: x["pro"],
//     con: x["con"],
//     type: string2Enum(x["type"]),
//     id: _uuid.v4());
//     await sqBox.put(me.id, jsonEncode(me.toJson()));
// }

// // var whatEndedUpinBox=sqBox.values.map((e)=>ShopQuality.fromJson(e)).cast<ShopQuality>().toList();
//   Box relationshipBox=Hive.box<String>("relationshipBox");
//   await relationshipBox.clear();

//   // Box locBox=Hive.box<String>("locationsBox");
//   // await locBox.clear();

// Box locationsRoleBox = Hive.box<String>("locationsRoleBox");
// Box locbox = Hive.box<String>("locbox");

// locationsRoleBox.clear();
// locbox.clear();
//   // myPeople.map((p)=>peopleBox.add(jsonEncode(p.toJson())));
//   // var whatEndedUpinBox=peopleBox.values.map((e)=>Person.fromJson(e)).cast<Person>().toList();
//   // bigShopBox=bigShopBox;
//   // var whatEndedUpinBigShopBox=bigShopBox.values.map((e)=>Shop.fromJson(e)).cast<Shop>().toList();
//   // print ("Halt and catch fire");

  
// }
  

  // class GovernmentViewer extends ConsumerWidget {
//   const GovernmentViewer({Key? key}) : super(key: key);
//   static const routeName = "/viewGoverments";
  
//   @override
//   Widget build(BuildContext context, WidgetRef ref) {
//     // Watch the governments list
//     final governmentsAsync = ref.watch(governmentsProvider);
    
//     // Watch the current selections
//     final selectedGovType = ref.watch(selectedGovernmentTypeProvider);
//     final selectedCitySize = ref.watch(selectedCitySizeProvider);
    
//     // Create the query for roles
//     final query = GovernmentQuery(selectedGovType, selectedCitySize);
    
//     // Watch both all possible roles and the selected roles based on the query
//     final allRolesAsync = ref.watch(governmentRolesProvider(query));
//     final selectedRolesAsync = ref.watch(selectedGovernmentRolesProvider(query));

//     return Scaffold(
//       appBar: AppBar(
//         title: const Text('Government System'),
//       ),
//       body: governmentsAsync.when(
//         loading: () => const Center(child: CircularProgressIndicator()),
//         error: (error, stack) => Center(
//           child: Text('Error: $error', style: const TextStyle(color: Colors.red)),
//         ),
//         data: (governments) {
//           return Column(
//             children: [
//               Padding(
//                 padding: const EdgeInsets.all(16.0),
//                 child: Row(
//                   children: [
//                     Expanded(
//                       child: DropdownButtonFormField<String>(
//                         decoration: const InputDecoration(
//                           labelText: 'Government Type',
//                           border: OutlineInputBorder(),
//                         ),
//                         value: selectedGovType,
//                         items: governments.map((government) {
//                           return DropdownMenuItem<String>(
//                             value: government.type,
//                             child: Text(government.printName),
//                           );
//                         }).toList(),
//                         onChanged: (String? newValue) {
//                           if (newValue != null) {
//                             ref.read(selectedGovernmentTypeProvider.notifier).state = newValue;
//                           }
//                         },
//                       ),
//                     ),
//                     const SizedBox(width: 16),
//                     Expanded(
//                       child: DropdownButtonFormField<String>(
//                         decoration: const InputDecoration(
//                           labelText: 'City Size',
//                           border: OutlineInputBorder(),
//                         ),
//                         value: selectedCitySize,
//                         items: [
//                           'thorp',
//                           'hamlet',
//                           'village',
//                           'town',
//                           'city',
//                           'metropolis',
//                         ].map((size) {
//                           return DropdownMenuItem<String>(
//                             value: size,
//                             child: Text(size.substring(0, 1).toUpperCase() + size.substring(1)),
//                           );
//                         }).toList(),
//                         onChanged: (String? newValue) {
//                           if (newValue != null) {
//                             ref.read(selectedCitySizeProvider.notifier).state = newValue;
//                           }
//                         },
//                       ),
//                     ),
//                   ],
//                 ),
//               ),
              
//               // Side-by-side role lists
//               Expanded(
//                 child: Row(
//                   crossAxisAlignment: CrossAxisAlignment.start,
//                   children: [
//                     // All possible roles column
//                     Expanded(
//                       child: Column(
//                         children: [
//                           const Padding(
//                             padding: EdgeInsets.all(8.0),
//                             child: Text(
//                               'All Possible Roles (Alphabetical)',
//                               style: TextStyle(
//                                 fontSize: 16,
//                                 fontWeight: FontWeight.bold,
//                               ),
//                             ),
//                           ),
//                           Expanded(
//                             child: _buildRolesList(allRolesAsync, true),
//                           ),
//                         ],
//                       ),
//                     ),
                    
//                     // Divider
//                     const VerticalDivider(thickness: 1, width: 1),
                    
//                     // Randomly selected roles column
//                     Expanded(
//                       child: Column(
//                         children: [
//                           const Padding(
//                             padding: EdgeInsets.all(8.0),
//                             child: Text(
//                               'Selected Roles (Alphabetical)',
//                               style: TextStyle(
//                                 fontSize: 16,
//                                 fontWeight: FontWeight.bold,
//                               ),
//                             ),
//                           ),
//                           Expanded(
//                             child: _buildRolesList(selectedRolesAsync, true),
//                           ),
//                           Padding(
//                             padding: const EdgeInsets.all(8.0),
//                             child: ElevatedButton(
//                               onPressed: () {
//                                 // Trigger a rebuild to generate a new selection
//                                 ref.refresh(selectedGovernmentRolesProvider(query));
//                               },
//                               child: const Text('Generate New Selection'),
//                             ),
//                           ),
//                         ],
//                       ),
//                     ),
//                   ],
//                 ),
//               ),
              
//               // Stats row
//               _buildStatsRow(allRolesAsync, selectedRolesAsync),
//             ],
//           );
//         },
//       ),
//     );
//   }

//   Widget _buildRolesList(AsyncValue<List<RoleResult>> rolesAsync, bool sortAlphabetically) {
//     return rolesAsync.when(
//       loading: () => const Center(child: CircularProgressIndicator()),
//       error: (error, stack) => Center(
//         child: Text('Error: $error', style: const TextStyle(color: Colors.red)),
//       ),
//       data: (roles) {
//         if (roles.isEmpty) {
//           return const Center(child: Text('No roles found for this configuration'));
//         }
        
//         // Sort the roles alphabetically if requested
//         if (sortAlphabetically) {
//           roles.sort((a, b) => a.title.compareTo(b.title));
//         }
        
//         return ListView.builder(
//           itemCount: roles.length,
//           itemBuilder: (context, index) {
//             final role = roles[index];
//             return Card(
//               margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
//               child: ListTile(
//                 title: Text(
//                   _formatTitleName(role.title), 
//                   style: const TextStyle(fontWeight: FontWeight.bold)
//                 ),
//                 subtitle: Text(_buildRoleDescription(role)),
//                 dense: true,
//               ),
//             );
//           },
//         );
//       },
//     );
//   }

//   Widget _buildStatsRow(
//     AsyncValue<List<RoleResult>> allRolesAsync, 
//     AsyncValue<List<RoleResult>> selectedRolesAsync
//   ) {
//     return Container(
//       padding: const EdgeInsets.all(8.0),
//       color: Colors.grey.shade200,
//       child: Row(
//         mainAxisAlignment: MainAxisAlignment.spaceEvenly,
//         children: [
//           _buildStatsItem(allRolesAsync, 'Total Available Roles'),
//           _buildStatsItem(selectedRolesAsync, 'Selected Roles'),
//           Builder(
//             builder: (context) {
//               // Calculate percentage of roles selected
//               if (allRolesAsync is AsyncData && selectedRolesAsync is AsyncData) {
//                 final allRolesCount = (allRolesAsync as AsyncData<List<RoleResult>>).value.length;
//                 final selectedRolesCount = (selectedRolesAsync as AsyncData<List<RoleResult>>).value.length;
                
//                 final percentage = allRolesCount > 0 
//                     ? (selectedRolesCount / allRolesCount * 100).toStringAsFixed(1) 
//                     : '0';
                
//                 return Container(
//                   padding: const EdgeInsets.all(8.0),
//                   decoration: BoxDecoration(
//                     borderRadius: BorderRadius.circular(4),
//                     color: Colors.white,
//                   ),
//                   child: Text(
//                     'Selected: $percentage%',
//                     style: const TextStyle(fontWeight: FontWeight.bold),
//                   ),
//                 );
//               }
              
//               return const SizedBox.shrink();
//             },
//           ),
//         ],
//       ),
//     );
//   }

//   Widget _buildStatsItem(AsyncValue<List<RoleResult>> rolesAsync, String label) {
//     return Container(
//       padding: const EdgeInsets.all(8.0),
//       decoration: BoxDecoration(
//         borderRadius: BorderRadius.circular(4),
//         color: Colors.white,
//       ),
//       child: Column(
//         children: [
//           Text(label, style: const TextStyle(fontSize: 12)),
//           if (rolesAsync is AsyncData)
//             Text(
//               '${(rolesAsync as AsyncData<List<RoleResult>>).value.length}',
//               style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
//             )
//           else
//             const Text('...'),
//         ],
//       ),
//     );
//   }

//   String _formatTitleName(String title) {
//     // Convert camelCase to Title Case with spaces
//     final result = title.replaceAllMapped(
//       RegExp(r'([A-Z])'),
//       (match) => ' ${match.group(0)}',
//     );
    
//     if (result.isNotEmpty) {
//       return result[0].toUpperCase() + result.substring(1);
//     }
//     return '';
//   }

//   String _buildRoleDescription(RoleResult role) {
//     final parts = <String>[];
    
//     if (role.quantity != null) {
//       parts.add('Quantity: ${role.quantity}');
//     }
    
//     if (role.proportion != null) {
//       parts.add('Proportion: ${role.proportion}');
//     }
    
//     if (role.role != null) {
//       parts.add('Role: ${role.role}');
//     }
    
//     return parts.isEmpty ? 'No details' : parts.join(' | ');
//   }
// }



// // Example page with dropdowns
// class GovernmentPositionSelectorPage extends ConsumerWidget {
//   const GovernmentPositionSelectorPage({Key? key}) : super(key: key);
//   static const routeName = '/governmentPositionsSelector';
//   @override
//   Widget build(BuildContext context, WidgetRef ref) {
//     final dataAsyncValue = ref.watch(governmentPositionsDataProvider);
//     final service = ref.watch(governmentPositionsServiceProvider);
    
//     final selectedGovernmentType = ref.watch(selectedGovernmentTypeProvider);
//     final selectedPosition = ref.watch(selectedPositionProvider);
    
//     return Scaffold(
//       appBar: AppBar(
//         title: const Text('Government Position Selector'),
//       ),
//       body: dataAsyncValue.when(
//         data: (_) => Padding(
//           padding: const EdgeInsets.all(16.0),
//           child: Column(
//             crossAxisAlignment: CrossAxisAlignment.start,
//             children: [
//               // Government Type Dropdown
//               Text(
//                 'Select Government Type:',
//                 style: Theme.of(context).textTheme.titleMedium,
//               ),
//               const SizedBox(height: 8),
//               Container(
//                 decoration: BoxDecoration(
//                   border: Border.all(color: Colors.grey),
//                   borderRadius: BorderRadius.circular(4),
//                 ),
//                 padding: const EdgeInsets.symmetric(horizontal: 12),
//                 width: double.infinity,
//                 child: DropdownButton<String>(
//                   value: selectedGovernmentType,
//                   isExpanded: true,
//                   underline: const SizedBox(),
//                   onChanged: (String? newValue) {
//                     if (newValue != null) {
//                       ref.read(selectedGovernmentTypeProvider.notifier).state = newValue;
//                     }
//                   },
//                   items: [
//                           'nobility',
//                           'merchantCouncil',
//                           'directDemocracy',
//                           'mageocracy',
//                           'theocracy',
//                           'councilOfElders',
//                           'tyranny',
//                           'cityCouncil',
//                         ].map((size) {
//                           return DropdownMenuItem<String>(
//                             value: size,
//                             child: Text(size.substring(0, 1).toUpperCase() + size.substring(1)),
//                           );
//                         }).toList(),
//                 ),
//               ),
              
//               const SizedBox(height: 24),
              
//               // Position Dropdown
//               Text(
//                 'Select Position:',
//                 style: Theme.of(context).textTheme.titleMedium,
//               ),
//               const SizedBox(height: 8),
//               Container(
//                 decoration: BoxDecoration(
//                   border: Border.all(color: Colors.grey),
//                   borderRadius: BorderRadius.circular(4),
//                 ),
//                 padding: const EdgeInsets.symmetric(horizontal: 12),
//                 width: double.infinity,
//                 child: DropdownButton<String>(
//                   value: selectedPosition,
//                   isExpanded: true,
//                   underline: const SizedBox(),
//                   hint: const Text('Select a position'),
//                   onChanged: (String? newValue) {
//                     if (newValue != null) {
//                       ref.read(selectedPositionProvider.notifier).state = newValue;
//                     }
//                   },
//                   items: service.getAllPositions().map((String position) {
//                     return DropdownMenuItem<String>(
//                       value: position,
//                       child: Text(
//                         _formatEnumName(position),
//                         style: Theme.of(context).textTheme.bodyLarge,
//                       ),
//                     );
//                   }).toList(),
//                 ),
//               ),
              
//               const SizedBox(height: 32),
              
//               // Results Section
//               if (selectedPosition != null)
//                 _buildResultSection(context, ref, selectedPosition, selectedGovernmentType),
//             ],
//           ),
//         ),
//         loading: () => const Center(child: CircularProgressIndicator()),
//         error: (error, _) => Center(
//           child: Padding(
//             padding: const EdgeInsets.all(16.0),
//             child: Text(
//               'Error loading government positions data: $error',
//               style: const TextStyle(color: Colors.red),
//             ),
//           ),
//         ),
//       ),
//     );
//   }
  
//   Widget _buildResultSection(
//     BuildContext context, 
//     WidgetRef ref, 
//     String position, 
//     String governmentType
//   ) {
//     final service = ref.watch(governmentPositionsServiceProvider);
//     final title = service.getTitleForPosition(position, governmentType);
//     final age = service.getRandomAgeForPosition(position);
    
//     if (title == null || age == null) {
//       return const Text('No data available for this selection.');
//     }
    
//     return Card(
//       elevation: 4,
//       child: Padding(
//         padding: const EdgeInsets.all(16.0),
//         child: Column(
//           crossAxisAlignment: CrossAxisAlignment.start,
//           children: [
//             Text(
//               'Results',
//               style: Theme.of(context).textTheme.titleLarge,
//             ),
//             const Divider(),
//             const SizedBox(height: 8),
//             Row(
//               children: [
//                 Expanded(
//                   flex: 2,
//                   child: Text(
//                     'Position:',
//                     style: Theme.of(context).textTheme.bodyLarge?.copyWith(
//                       fontWeight: FontWeight.bold,
//                     ),
//                   ),
//                 ),
//                 Expanded(
//                   flex: 3,
//                   child: Text(
//                     _formatEnumName(position),
//                     style: Theme.of(context).textTheme.bodyLarge,
//                   ),
//                 ),
//               ],
//             ),
//             const SizedBox(height: 8),
//             Row(
//               children: [
//                 Expanded(
//                   flex: 2,
//                   child: Text(
//                     'Government:',
//                     style: Theme.of(context).textTheme.bodyLarge?.copyWith(
//                       fontWeight: FontWeight.bold,
//                     ),
//                   ),
//                 ),
//                 Expanded(
//                   flex: 3,
//                   child: Text(
//                     _formatEnumName(governmentType),
//                     style: Theme.of(context).textTheme.bodyLarge,
//                   ),
//                 ),
//               ],
//             ),
//             const SizedBox(height: 8),
//             Row(
//               children: [
//                 Expanded(
//                   flex: 2,
//                   child: Text(
//                     'Title:',
//                     style: Theme.of(context).textTheme.bodyLarge?.copyWith(
//                       fontWeight: FontWeight.bold,
//                     ),
//                   ),
//                 ),
//                 Expanded(
//                   flex: 3,
//                   child: Text(
//                     title,
//                     style: Theme.of(context).textTheme.bodyLarge?.copyWith(
//                       fontWeight: FontWeight.bold,
//                       color: Theme.of(context).primaryColor,
//                     ),
//                   ),
//                 ),
//               ],
//             ),
//             const SizedBox(height: 8),
//             Row(
//               children: [
//                 Expanded(
//                   flex: 2,
//                   child: Text(
//                     'Age Category:',
//                     style: Theme.of(context).textTheme.bodyLarge?.copyWith(
//                       fontWeight: FontWeight.bold,
//                     ),
//                   ),
//                 ),
//                 Expanded(
//                   flex: 3,
//                   child: Text(
//                     _formatEnumName(age.name),
//                     style: Theme.of(context).textTheme.bodyLarge,
//                   ),
//                 ),
//               ],
//             ),
//             const SizedBox(height: 16),
//             SizedBox(
//               width: double.infinity,
//               child: ElevatedButton(
//                 onPressed: () {
//                   // Re-roll the age by forcing a refresh of the page
//                   ref.invalidate(selectedPositionProvider);
//                   ref.read(selectedPositionProvider.notifier).state = position;
//                 },
//                 child: const Text('Re-roll Age'),
//               ),
//             ),
//           ],
//         ),
//       ),
//     );
//   }
  
//   // Helper method to format enum names for display
//   String _formatEnumName(String name) {
//     // Convert camelCase to Title Case with Spaces
//     final result = name.replaceAllMapped(
//       RegExp(r'([A-Z])'),
//       (Match match) => ' ${match.group(1)}',
//     );
    
//     // Capitalize first letter and trim
//     return result.substring(0, 1).toUpperCase() + result.substring(1).trim();
//   }
// }


// class RelationshipProvider extends StateNotifier<List<Node>> {
//   Box<String> myBox;
//   RelationshipProvider({required this.myBox, List<Node>? nodes})
//     : super(nodes ?? []);

//   Future<int> countPartner(String p1) async {
//     int index = state.indexWhere((n) => n.id == p1);
//     if (index == -1) {
//       return 0;
//     } else {
//       return state[index].relPairs
//           .where((e) => e.iAmYour == RelationshipType.partner)
//           .length;
//     }
//   }

//   Future<void> addRelationship(
//     String p1,
//     String p2,
//     RelationshipType p1isp2s,
//   ) async {
//     await _lock.synchronized(() async {
//       int nodeIndex = state.indexWhere((n) => n.id == p1);
//       if (nodeIndex == -1) {
//         Node me = Node(id: p1, relPairs: {Edge(you: p2, iAmYour: p1isp2s)});
//         await myBox.put(p1, jsonEncode(me.toJson()));
//       } else {
//         Node me = state[nodeIndex];
//         if (!me.relPairs.contains(Edge(you: p2, iAmYour: p1isp2s))) {
//           me = me.addRelationship(p2, p1isp2s);
//           await myBox.put(p1, jsonEncode(me.toJson()));
//         }
//       }
//       state = myBox.values.map((v) => Node.fromJson(v)).cast<Node>().toList();
//     });
//   }

//   Future<void> addSymmetricRelationship(
//     String p1,
//     String p2,
//     RelationshipType symRel,
//   ) async {
//     await addRelationship(p1, p2, symRel);
//     await addRelationship(p2, p1, symRel);
//   }

//   Future<void> removeRelationship(
//     String p1,
//     String p2,
//     RelationshipType p1isp2s,
//   ) async {
//     int nodeIndex = state.indexWhere((n) => n.id == p1);
//     if (nodeIndex != -1) {
//       Node me = state[nodeIndex];
//       me.relPairs.removeWhere((e) => (e.you == p2) && (e.iAmYour == p1isp2s));
//       await myBox.put(me.id, jsonEncode(me.toJson()));
//     }
//     state = myBox.values.map((v) => Node.fromJson(v)).cast<Node>().toList();
//   }

//   Future<void> removeSymmetricRelationship(
//     String p1,
//     String p2,
//     RelationshipType symRel,
//   ) async {
//     await removeRelationship(p1, p2, symRel);
//     await removeRelationship(p2, p1, symRel);
//   }

//   Future<void> addParentChild(String parent, String child) async {
//     await addRelationship(parent, child, RelationshipType.parent);
//     await addRelationship(child, parent, RelationshipType.child);
//   }

//   Future<void> makeExes(String x, String y) async {
//     await removeSymmetricRelationship(x, y, RelationshipType.partner);
//     await addSymmetricRelationship(x, y, RelationshipType.ex);
//   }

//   Future<int> getI(String s) async {
//     return state.indexWhere((e) => e.id == s);
//   }

//   Future<void> findAndMakeSiblings(String c) async {
//     int meIndex = await getI(c);
//     List<String> csParents =
//         state[meIndex].relPairs
//             .where((e) => e.iAmYour == RelationshipType.parent)
//             .map((e) => e.you)
//             .toList();
//     List<String> parentsChildren = [];
//     for (String p in csParents) {
//       parentsChildren.addAll(
//         state[await getI(p)].relPairs
//             .where((e) => (e.iAmYour == RelationshipType.child))
//             .map((q) => q.you)
//             .where((i) => i != c),
//       );
//     }
//     for (String s in parentsChildren) {
//       await addSymmetricRelationship(s, c, RelationshipType.sibling);
//     }
//   }

//   Future<List<String>> findRelationshipOfType(
//     String myID,
//     Set<RelationshipType> findTypes,
//   ) async {
//     Node myNode = state.firstWhere((n) => n.id == myID);
//     return myNode.relPairs
//         .where((rp) => findTypes.contains(rp.iAmYour))
//         .map((rp) => rp.you)
//         .toList();
//   }

//   Future<void> bulkAddNodes(List<Node> nodeList) async {
//     await _lock.synchronized(() async {
//       Map<String, String> addMe = {
//         for (var n in nodeList) n.id: jsonEncode(n.toJson()),
//       };
//       await myBox.putAll(addMe);
//       state = myBox.values.map((v) => Node.fromJson(v)).cast<Node>().toList();
//     });
//   }

//   Future<void> overwriteState(List<Node> nodeList) async {
//     await myBox.clear();
//     await bulkAddNodes(nodeList);
//   }

//   // factory RelationshipDigraph.fromBox(Box b)
//   // {
//   //   return RelationshipDigraph(nodes: b.values.map((v)=>Node.fromJson(v)).cast<Node>().toList());
//   // }
// }
// class RolesContainer extends ProviderList<RoleGeneration> {
//   static double priorityTavernChance = 0.5;
//   static double priorityCustomerChance = 0.5;

//   int? _cachedAll;
//   int? _cachedAllTavern;
//   int? _cachedAllPriorityTavern;
//   int? _cachedAllPriorityCustomer;

//   // RolesContainer({required super.myBox}) : super(fromJson: RoleGeneration.fromJson);

//   @override
//   set state(List<RoleGeneration> newState) {
//     // Invalidate the cache whenever the state changes
//     _cachedAll = null;
//     _cachedAllTavern = null;
//     _cachedAllPriorityTavern = null;
//     _cachedAllPriorityCustomer = null;
//     super.state = newState; // Call the superclass's setter
//   }

//   int get all {
//     return _cachedAll ?? state.fold<int>(0, (v, r) => v + r.onePerHowMany);
//   }

//   int get allTavern {
//     return _cachedAllTavern ??state
//           .where((tr) => tr.promoteInTaverns)
//           .fold<int>(0, (v, r) => v + r.onePerHowMany) ;
//   }

//   int get allPriorityTavern {
//     return _cachedAllPriorityTavern ?? state
//           .where((tr) => tr.promoteInTaverns && tr.priorityInTaverns)
//           .fold<int>(0, (v, r) => v + r.onePerHowMany);
//   }

//   int get allPriorityCustomer {
//     return _cachedAllPriorityCustomer ?? state
//           .where((tr) => tr.prioritizeCustomer)
//           .fold<int>(0, (v, r) => v + r.onePerHowMany);
//   }

//   String getString(Role myRole,{bool? plural,WidgetRef? ref})
//   {
    
//     if(myRole.name.contains("Government")){
//       if(ref != null){
//       return stringForHeaders(ref,myRole);
//       }else{return "Govenrment Official";}
//     }
    

//     if(myRole==Role.owner){
//       if(plural != null && plural){
//         return "Owners";
//       }else{
//         return "Owner";
//       }
//     }

//     if(myRole==Role.customer){
//       if(plural != null && plural){
//         return "Customers";
//       }else{
//         return "Customer";
//       }
//     }
//     if(myRole==Role.regular){
//       if(plural != null && plural){
//         return "Regulars";
//       }else{
//         return "Regular";
//       }
//     }

//     if(myRole == Role.minorNoble){
//       if(plural != null && plural){
//         return "Minor Nobles";
//       }else{
//         return "Minor Noble";
//       }
//     }
//     int i = state.indexWhere((s)=>s.thisRole==myRole);
    
//     if(i==-1) {return "Role not found";}
//     else{
//       if(plural != null && plural){
//           return state[i].plural;
//       }
//       return state[i].singular;
//     }
//   }

//   Role getTavernRegularRole(){
//     double pt = random.nextDouble();
//     double r;
//     List<RoleGeneration> subRoles;
//     if(pt < priorityTavernChance){
//       List<RoleGeneration> subRoles = state.where((tr)=>tr.priorityInTaverns).toList();

//       r = random.nextDouble();
//       for(int i = 0; i<subRoles.length; i++){
//         r-=1/subRoles[i].onePerHowMany;
//         if(r<0){ return subRoles[i].thisRole;}
//       }
//     }
//     subRoles=state.where((tr)=>tr.promoteInTaverns).toList();
//     r=random.nextDouble();
    
//     for(int i = 0; i<subRoles.length; i++){
//         r-=1/subRoles[i].onePerHowMany;
//         if(r<0){ return subRoles[i].thisRole;}
//     }

//     return randomElement(subRoles.map((s)=>s.thisRole).toList());
//   }

//   Role getCustomerRole(){
//     double pt = random.nextDouble();
//     double r;
//     List<RoleGeneration> subRoles;
//     if(pt < priorityCustomerChance){
//       List<RoleGeneration> subRoles = state.where((tr)=>tr.prioritizeCustomer).toList();

//       r = random.nextDouble();
//       for(int i = 0; i<subRoles.length; i++){
//         r-=1/subRoles[i].onePerHowMany;
//         if(r<0){ return subRoles[i].thisRole;}
//       }
//     }
//     subRoles=state;
//     r=random.nextDouble();
    
//     for(int i = 0; i<subRoles.length; i++){
//         r-=1/subRoles[i].onePerHowMany;
//         if(r<0){ return subRoles[i].thisRole;}
//     }

//     return randomElement(subRoles.map((s)=>s.thisRole).toList());
//   }
//   Role getRole()
//   {
//     double r=random.nextDouble();
    
//     for(int i = 0; i<state.length; i++){
//         r-=1/state[i].onePerHowMany;
//         if(r<0){ return state[i].thisRole;}

//     }
//     return randomElement(state.map((s)=>s.thisRole).toList());
//   }

//   AgeType getAgeOfRole(Role r)
//   {
//     List<AgeType> myAges = state.firstWhere((s)=>s.thisRole==r).validAges.toList();
//     return randomElement(myAges);
//   }
//   Set<AgeType> getAllAgesOfRole(Role r)
//   {
//     return state.firstWhere((s)=>s.thisRole==r).validAges.toSet();
//   }

//   Future<void> overwriteFromJson(List<Map<String,dynamic>>jsonList)async{
//     myBox.clear();
//     for(final j in jsonList){ await add(addMe: RoleGeneration.fromJson(j));}
//   }


// }



// class locationGeneration{
//   ShopType thisShop;
//   int onePerHowMany;
//   List<Role> associatedRoles;
//   List<CitySize> atLeastOne;

// }


// import 'package:flutter/material.dart';
// import 'package:flutter/services.dart';
// // import 'dart:io';
// // import 'package:flutter_hooks/flutter_hooks.dart';
// import 'package:hooks_riverpod/hooks_riverpod.dart';
// // import 'package:firetown/navrail.dart';
// // import 'package:firetown/personEdit.dart';
// import 'package:firetown/shops_view.dart';
// // import 'shop.dart';
// // import 'person.dart';
// // import 'bottombar.dart';
// import "globals.dart";
// // import "editHelpers.dart";
// // import "personDetailView.dart";
// // import "peopleView.dart";
// // import "new_shops.dart";


// class SaveLoad extends HookConsumerWidget {
//   const SaveLoad({super.key});
//   static const routeName="/saveload";
  
//   @override
//   Widget build(BuildContext context, WidgetRef ref) {    
//     return ListView(
//           padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 40),
//           children: [
//             const SizedBox(height: 42),
//             // ElevatedButton(
//             //     onPressed: ()async{
//             //                     await readTownFiles();
//             //                     print(newShopsJson);
//             //                     // ref.read(shopListProvider.notifier).overwrite(ShopList.fromJson(newShopsJson));
//             //                     // ref.read(shopListProvider.notifier).addJSONoldStyle(jsonString:tavernsJson, myShop: ShopType.tavern);
//             //                     // ref.read(peopleListProvider.notifier).overwrite(PeopleList.fromJson(newPeopleJson));
//             //                     // peopleListProvider = StateNotifierProvider<PeopleList, List<Person>>((ref) {
//             //                     // return PeopleList.fromJson(newPeopleJson);
//             //                     // });
//             //                     // ref.read(tavernListProvider.notifier).addJSON(tavernsJson);
//             //                     // ref.read(ancestryListProvider.notifier).addJSON(ancestriesJson);
//             //                     navigatorKey.currentState!.restorablePushNamed(
//             //                     ShopsView.routeName,
//             //                     );
//             //                   }, // Action for the button
//             //     child: const Text('Load Data'), // Button label
//             //   ),  
//               ElevatedButton(
//                 onPressed: ()async{
//               //                     newShopsJson=ref.read(shopListProvider.notifier).toJson();
//               //                     newPeopleJson=ref.read(peopleListProvider.notifier).toJson();
                                
//               //                     var file = File('myShops.json');

//               // //                   // Ensure the directory exists, and create it if necessary
//               //                       await file.create(recursive: true);

//               // //                   // Write the string to the file
//               //                       await file.writeAsString(newShopsJson);

//               // //                   // throw('File written successfully to ${file.path}');
//               //                   file = File('myPeople.json');

//               // //                   // Ensure the directory exists, and create it if necessary
//               //                   await file.create(recursive: true);

//               // //                   // Write the string to the file
//               //                     await file.writeAsString(newPeopleJson);

//                                     // ref.read(ref.read(townProvider).shopListProvider.notifier).writeBigBox();
//               //                   // print('File written successfully to ${file.path}');
//               //                   navigatorKey.currentState!.restorablePushNamed(
//               //                   ShopsView.routeName,
//               //                   );
//                               }, // Action for the button
//                 child: const Text('Save Json please'), // Button label
//               ),  
//               ElevatedButton(
//                 onPressed: (){
//                                 navigatorKey.currentState!.pushNamed(
//                                 ShopsView.routeName,
//                                 );
//                               }, // Action for the button
//                 child: const Text('Return to Town'), // Button label
//               ),            
//           ],
//     );
//   }
// }




// String newShopsJson="";
// String newPeopleJson="";
// Future<void> readTownFiles() async {
//   WidgetsFlutterBinding.ensureInitialized();
//    try {
//     newShopsJson = await rootBundle.loadString('./lib/demofiles/myShops.json');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
//   try {
//     newPeopleJson = await rootBundle.loadString('./lib/demofiles/myPeople.json');
//   } catch (e) {
//     throw("Error loading JSON: $e");
//   }
// }

import 'dart:convert';

// // import 'package:flutter/foundation.dart' show immutable;
// import 'package:hooks_riverpod/hooks_riverpod.dart';
// import 'package:riverpod/riverpod.dart';
// // import 'package:uuid/uuid.dart';
// import 'package:flutter/material.dart';
// // import 'package:firetown/given_names.dart';
// // import 'package:firetown/resonant_argument.dart';
// // import 'package:firetown/surnames.dart';
// // import 'package:firetown/providers.dart';
// // import "personEdit.dart";
// // import "quirks.dart";
// // import "dart:math";
// import "package:hive/hive.dart";

// import "models/person_model.dart";
// import "models/town_extension/town_locations.dart";
// import "providers/barrel_of_providers.dart";

// @immutable
// class TrieNode {
//   final Map<String, TrieNode> children;
//   final Set<String> ids;

//   TrieNode({Map<String, TrieNode>? children, Set<String>? ids})
//       : children = children ?? {},
//         ids = ids ?? {};

//   /// Convert TrieNode to JSON
//   Map<String, dynamic> toJson() {
//     return {
//       "children": children.map((key, value) => MapEntry(key, value.toJson())),
//       "ids": ids.toList(),
//     };
//   }

//   /// Create TrieNode from JSON
//   factory TrieNode.fromJson(Map<String, dynamic> json) {
//     return TrieNode(
//       children: (json["children"] as Map<String, dynamic>).map(
//         (key, value) => MapEntry(key, TrieNode.fromJson(value)),
//       ),
//       ids: Set<String>.from(json["ids"] ?? []),
//     );
//   }

//   /// Helper to create a modified copy (since it's immutable)
//   TrieNode copyWith({Map<String, TrieNode>? children, Set<String>? ids}) {
//     return TrieNode(
//       children: children ?? this.children,
//       ids: ids ?? this.ids,
//     );
//   }
// }

// class Trie extends StateNotifier<Map<String,Set<String>>>{
//   final TrieNode root;
//   final Box myBox;

//  Trie({required this.myBox})
//     : root = TrieNode.fromJson(jsonDecode(myBox.get("root") ?? jsonEncode(TrieNode().toJson()))),
//       super(Map.fromEntries(
//           myBox.keys.where((k) => k != "root").map((k) {
//             var decoded = jsonDecode(myBox.get(k) ?? '[]');

//             // Ensure decoded data is a list, otherwise default to an empty list
//             if (decoded is! List) {
//               decoded = [];
//             }

//             return MapEntry(k, Set<String>.from(decoded));
//           })
//       ));

//   Future<void> addPersonToSearch(Person p) async{
//     await insert(p.firstName,p.id);
//     await insert(p.surname,p.id);
//     await insert(p.quirk1,p.id);
//     await insert(p.quirk2,p.id);
//     await insert(p.resonantArgument,p.id);
//   }
//    Future<void> addLocationToSearch(Location ell) async{
//     await insert(ell.name,ell.id);
//     await insert(ell.blurbText,ell.id);
//   }
//   Future<void> addShopToSearch(Shop s) async{
//     addLocationToSearch(s);
//     await insert(s.pro1,s.id);
//     await insert(s.pro2,s.id);
//     await insert(s.con,s.id);
//   }
//   /// Insert a shop name with an associated UUID
//   Future<void> insert(String word, String id) async{
//     TrieNode node = root;
//     for (var char in word.split('')) {
//       node.children.putIfAbsent(char, () => TrieNode());
//       node = node.children[char]!;
//     }
//     node.ids.add(id);
//     Set<String> myWord = Set<String>.from(jsonDecode(await myBox.get(word) ?? jsonEncode([])));
//     myWord.add(id);
//     await myBox.put(word,jsonEncode(myWord.toList()));
    
//     await myBox.put("root",jsonEncode(root.toJson()));

//     state.putIfAbsent(word, () => <String>{}).add(id);
//   }

//   /// Exact search for a shop name
//   Set<String> search(String word) {
//     TrieNode? node = _getNode(word);
//     return node != null ? node.ids : {};
//   }

//   /// Get all shop IDs for words starting with the given prefix
//   Set<String> getIdsWithPrefix(String prefix) {
//     TrieNode? node = _getNode(prefix);
//     if (node == null) return {};
//     Set<String> ids = {};
//     _collectIds(node, ids);
//     return ids;
//   }

//   /// Fuzzy search using Levenshtein Distance, substring detection, and prefix scoring
//   List<String> searchFuzzy(String query, {int maxDistance = 2}) {
//     query = query.toLowerCase();
//     List<(String, int, int)> results = []; // (shopName, levenshteinDistance, rankingScore)
    
//     for (var entry in state.entries) {
//       String shopName = entry.key.toLowerCase();
//       int levenshteinScore = levenshtein(query, shopName);
//       int rankScore = _calculateRelevance(query, shopName, levenshteinScore);

//       if (levenshteinScore <= maxDistance || shopName.contains(query)) {
//         results.add((entry.key, levenshteinScore, rankScore));
//       }
//     }

//     // Sort by ranking score (higher is better), then by Levenshtein distance (lower is better)
//     results.sort((a, b) {
//       int rankComparison = b.$3.compareTo(a.$3); // Higher rank first
//       if (rankComparison != 0) return rankComparison;
//       return a.$2.compareTo(b.$2); // Lower Levenshtein distance first
//     });

//     // Collect and return the UUIDs of the best matches
//     Set<String> bestIds = {};
//     for (var result in results) {
//       bestIds.addAll(state[result.$1] ?? {});
//     }
//     return bestIds.toList();
//   }

//   /// Calculate a ranking score based on similarity
//   int _calculateRelevance(String query, String name, int levDist) {
//     int score = 0;

//     if(name==query){
      
//       score= 100000;
//     }
//     if (name.startsWith(query)) {
//       score += 40; // Prefix match is very relevant
//     }
//     if (name.contains(query)) {
//       score += 10; // Substring match is relevant
//     }

//     score -= (levDist * 3).clamp(0, 40); // Penalize for higher Levenshtein distance
    
//     return score;
//   }

//   /// Remove a specific shop UUID from a name
//   Future<void> remove(String word, String id) async{
//     TrieNode? node = _getNode(word);
//     if (node == null) return;
//     node.ids.remove(id);

//     if (node.ids.isEmpty) {
//       _cleanup(root, word, 0);
//     }

//     state[word]?.remove(id);
//     if (state[word]?.isEmpty ?? false) {
//       state.remove(word);
//     }

//     Set<String> myWord = Set<String>.from(jsonDecode(await myBox.get(word) ?? jsonEncode([])));
//     myWord.remove(id);
//     if (myWord.isEmpty) {
//        await myBox.delete(word);
//       } else {
//        await myBox.put(word, jsonEncode(myWord.toList()));
//     }
    
//     await myBox.put("root",jsonEncode(root.toJson()));

//   }

//   /// Edit a shop name by removing the old name and inserting the new one
//   void edit(String oldName, String newName, String id) {
//     remove(oldName, id);
//     insert(newName, id);
//   }


//   /// Traverse the Trie to find a word or prefix
//   TrieNode? _getNode(String prefix) {
//     TrieNode node = root;
//     for (var char in prefix.split('')) {
//       if (!node.children.containsKey(char)) return null;
//       node = node.children[char]!;
//     }
//     return node;
//   }

//   /// Collect UUIDs from all descendant nodes
//   void _collectIds(TrieNode node, Set<String> ids) {
//     ids.addAll(node.ids);
//     for (var child in node.children.values) {
//       _collectIds(child, ids);
//     }
//   }

//   /// Cleanup empty nodes
//   bool _cleanup(TrieNode node, String word, int index) {
//     if (index == word.length) {
//       return node.ids.isEmpty && node.children.isEmpty;
//     }

//     String char = word[index];
//     if (!node.children.containsKey(char)) return false;

//     bool shouldDeleteChild = _cleanup(node.children[char]!, word, index + 1);

//     if (shouldDeleteChild) {
//       node.children.remove(char);
//       return node.ids.isEmpty && node.children.isEmpty;
//     }

//     return false;
//   }

//   /// Levenshtein Distance Algorithm (Edit Distance)
//   int levenshtein(String s1, String s2) {
//     if (s1.isEmpty) return s2.length;
//     if (s2.isEmpty) return s1.length;

//     List<List<int>> dp = List.generate(
//       s1.length + 1,
//       (_) => List.filled(s2.length + 1, 0),
//     );

//     for (int i = 0; i <= s1.length; i++) {dp[i][0] = i;}
//     for (int j = 0; j <= s2.length; j++) {dp[0][j] = j;}

//     for (int i = 1; i <= s1.length; i++) {
//       for (int j = 1; j <= s2.length; j++) {
//         int cost = (s1[i - 1] == s2[j - 1]) ? 0 : 1;
//         dp[i][j] = [dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost].reduce((a, b) => a < b ? a : b);
//       }
//     }
//     return dp[s1.length][s2.length];
//   }
// }


// // import "dart:convert";
// // import 'package:flutter/services.dart';
// // import 'package:flutter/material.dart';
// // // import 'package:flutter_hooks/flutter_hooks.dart';
// // import 'package:hooks_riverpod/hooks_riverpod.dart';
// // import "package:firetown/demo_determine.dart";
// // import "package:firetown/demographics.dart";
// // import "package:firetown/hirelings_view.dart";
// // import "package:firetown/loading_view.dart";
// // import "package:firetown/market_view.dart";
// // // import "package:firetown/demographics_edit_view.dart";
// // // import "package:firetown/demographics_view.dart";
// // // import 'package:firetown/navrail.dart';
// // import 'package:firetown/person_edit.dart';
// // import "package:firetown/providers.dart";
// // import "package:firetown/roles.dart";
// // import 'load_json.dart';
// // // import 'providers.dart';
// // // import 'shop.dart';
// // import 'person.dart';
// // // import 'new_shops.dart';
// // // import 'bottombar.dart';
// // import "globals.dart";
// // // import "editHelpers.dart";
// // import "person_detail_view.dart";
// // import "people_view.dart";
// // import "shops_view.dart";
// // import "shop_edit_view.dart";
// // import "shop_detail_view.dart";
// // import "home.dart";
// // import "save_load.dart";
// // import "town.dart";
// // import "enums_and_maps.dart";
// // import "demo_determine.dart";
// // import "sages_view.dart";
// // import "package:flutter/foundation.dart";
// // import "package:uuid/uuid.dart";
// // import "services.dart";
// // import "generic_list.dart";

// // import "package:hive_flutter/hive_flutter.dart";
// // import "town_extension/town_locations.dart";

// // enum SearchType{
// //   location,
// //   person,
// // }
// // enum FilterType{
// //   quirk,
// //   name,
// //   people,
// //   locations,
// //   services,
// //   description,
// // }

// // @immutable
// // class SearchKey implements JsonSerializable{
// //   final String key;
// //   final String id;
// //   final SearchType whichList;
// //   final List<FilterType> myFilters;

// //   const SearchKey({required this.key,required this.id,required this.whichList,required this.myFilters});

// //   @override
// //   Map<String,dynamic> toJson(){
// //     return {
// //       "key": key,
// //       "id" : id,
// //       "whichList" : whichList.name,
// //       "myFilters" : myFilters.map((f)=>f.name).toList(),
// //     };
// //   }

// //   factory SearchKey.fromJson(json){
// //     return SearchKey(
// //       id: json["id"],
// //       key: json["key"],
// //       whichList: SearchType.values.firstWhere((v)=>v.name == json["whichList"]),
// //       myFilters: (json["myfilters"] as List).map((f)=>FilterType.values.firstWhere((v)=>v.name==f)).toList(),
// //     );
// //   }
// // }

// // class SearchList extends ProviderList<SearchKey> {
// //   SearchList({required super.myBox}):super(fromJson: SearchKey.fromJson);

// //   Future<void> addLocation(Location loc)async{
// //     await add(id:"name_${loc.id}", 
// //           addMe:SearchKey(id: loc.id,
// //                    whichList: SearchType.location, 
// //                    myFilters: [FilterType.locations,FilterType.name],
// //                    key: loc.name,
// //                    ));
// //     await add(id:"blurbText_${loc.id}", 
// //           addMe:SearchKey(id: loc.id,
// //                    whichList: SearchType.location, 
// //                    myFilters: [FilterType.locations,FilterType.description],
// //                    key: loc.blurbText,
// //                    ));
// //   }
// //   Future<void> editLocation(Location loc)async{
// //       await replace(replaceID:"name_${loc.id}", 
// //             replacement:SearchKey(id: loc.id,
// //                     whichList: SearchType.location, 
// //                     myFilters: [FilterType.locations,FilterType.name],
// //                     key: loc.name,
// //                     ));
// //       await replace(replaceID:"blurbText_${loc.id}", 
// //             replacement:SearchKey(id: loc.id,
// //                     whichList: SearchType.location, 
// //                     myFilters: [FilterType.locations,FilterType.description],
// //                     key: loc.blurbText,
// //                     ));
// //     }
// //   Future<void> removeLocation(Location loc)async{
// //       await delete("name_${loc.id}");
// //       await delete("blurbText_${loc.id}");
// //     }
  
  
// //   Future<void> addShop(Shop shop)async{
// //     await addLocation(shop);


// //     await add(id:"pro1_${shop.id}", 
// //           addMe:SearchKey(id: shop.id,
// //                    whichList: SearchType.location, 
// //                    myFilters: [FilterType.locations,FilterType.quirk],
// //                    key: shop.pro1,
// //                    ));
// //     await add(id:"pro2_${shop.id}", 
// //           addMe:SearchKey(id: shop.id,
// //                    whichList: SearchType.location, 
// //                    myFilters: [FilterType.locations,FilterType.quirk],
// //                    key: shop.pro2,
// //                    ));
// //     await add(id:"con_${shop.id}", 
// //           addMe:SearchKey(id: shop.id,
// //                    whichList: SearchType.location, 
// //                    myFilters: [FilterType.locations,FilterType.quirk],
// //                    key: shop.con,
// //                    ));                   
// //   }
// //   Future<void> editShop(Shop shop)async{
// //       await editLocation(shop);
// //       await replace(replaceID:"pro1_${shop.id}", 
// //           replacement:SearchKey(id: shop.id,
// //                    whichList: SearchType.location, 
// //                    myFilters: [FilterType.locations,FilterType.quirk],
// //                    key: shop.pro1,
// //                    ));
// //     await replace(replaceID:"pro2_${shop.id}", 
// //           replacement:SearchKey(id: shop.id,
// //                    whichList: SearchType.location, 
// //                    myFilters: [FilterType.locations,FilterType.quirk],
// //                    key: shop.pro2,
// //                    ));
// //     await replace(replaceID:"con_${shop.id}", 
// //           replacement:SearchKey(id: shop.id,
// //                    whichList: SearchType.location, 
// //                    myFilters: [FilterType.locations,FilterType.quirk],
// //                    key: shop.con,
// //                    ));
// //     }
// //   Future<void> removeShop(Shop shop)async{
// //       await removeLocation(shop);
// //       await delete("pro1_${shop.id}");
// //       await delete("pro2_${shop.id}");
// //       await delete("con_${shop.id}");
// //   }


 
// //   Future<void> addPerson(Person p)async{
// //     await add(id:"firstname_${p.id}", 
// //           addMe:SearchKey(id: p.id,
// //                    whichList: SearchType.person, 
// //                    myFilters: [FilterType.people,FilterType.name],
// //                    key: p.firstName,
// //                    ));
// //     await add(id:"surname_${p.id}", 
// //           addMe:SearchKey(id: p.id,
// //                    whichList: SearchType.person, 
// //                    myFilters: [FilterType.people,FilterType.name],
// //                    key: p.surname,
// //                    ));

// //     await add(id:"quirk1_${p.id}", 
// //           addMe:SearchKey(id: p.id,
// //                    whichList: SearchType.person, 
// //                    myFilters: [FilterType.people,FilterType.quirk],
// //                    key: p.quirk1,
// //                    ));

// //     await add(id:"quirk2_${p.id}", 
// //           addMe:SearchKey(id: p.id,
// //                    whichList: SearchType.person, 
// //                    myFilters: [FilterType.people,FilterType.quirk],
// //                    key: p.quirk2,
// //                    ));

// //   }
// //     Future<void> editPerson(Person p)async{
// //     await replace(replaceID:"firstname_${p.id}", 
// //           replacement:SearchKey(id: p.id,
// //                    whichList: SearchType.person, 
// //                    myFilters: [FilterType.people,FilterType.name],
// //                    key: p.firstName,
// //                    ));
// //     await replace(replaceID:"surname_${p.id}", 
// //           replacement:SearchKey(id: p.id,
// //                    whichList: SearchType.person, 
// //                    myFilters: [FilterType.people,FilterType.name],
// //                    key: p.surname,
// //                    ));

// //     await replace(replaceID:"quirk1_${p.id}", 
// //           replacement:SearchKey(id: p.id,
// //                    whichList: SearchType.person, 
// //                    myFilters: [FilterType.people,FilterType.quirk],
// //                    key: p.quirk1,
// //                    ));

// //     await replace(replaceID:"quirk2_${p.id}", 
// //           replacement:SearchKey(id: p.id,
// //                    whichList: SearchType.person, 
// //                    myFilters: [FilterType.people,FilterType.quirk],
// //                    key: p.quirk2,
// //                    ));

// //   }
// //   Future<void> removePerson(Person p) async{
// //       await delete("firstname_${p.id}");
// //       await delete("surname_${p.id}");
// //       await delete("quirk1_${p.id}");
// //       await delete("quirk2_${p.id}");
// //     }

// //   Future<void> addSearch(dynamic x) async{
// //     if(x is Location){
// //       addLocation(x);
// //     }else if(x is Shop){
// //       addShop(x);
// //     }else if(x is Person){
// //       addPerson(x);
// //     }else{
// //       throw ArgumentError("Unsupported type: ${x.runtimeType}");
// //     }
// //   }
// //   Future<void> editSearch(dynamic x) async{
// //     if(x is Location){
// //       editLocation(x);
// //     }else if(x is Shop){
// //       editShop(x);
// //     }else if(x is Person){
// //       editPerson(x);
// //     }else{
// //       throw ArgumentError("Unsupported type: ${x.runtimeType}");
// //     }
// //   }
// //     Future<void> removeSearch(dynamic x) async{
// //     if(x is Location){
// //       removeLocation(x);
// //     }else if(x is Shop){
// //       removeShop(x);
// //     }else if(x is Person){
// //       removePerson(x);
// //     }else{
// //       throw ArgumentError("Unsupported type: ${x.runtimeType}");
// //     }
// //   }


// // }

// // int levenshteinDistance(String s1, String s2) {
// //   if (s1.isEmpty) return s2.length;
// //   if (s2.isEmpty) return s1.length;

// //   List<List<int>> dp = List.generate(
// //     s1.length + 1,
// //     (_) => List.filled(s2.length + 1, 0),
// //   );

// //   for (int i = 0; i <= s1.length; i++) {dp[i][0] = i;}
// //   for (int j = 0; j <= s2.length; j++) {dp[0][j] = j;}

// //   for (int i = 1; i <= s1.length; i++) {
// //     for (int j = 1; j <= s2.length; j++) {
// //       int cost = (s1[i - 1] == s2[j - 1]) ? 0 : 1;
// //       dp[i][j] = [
// //         dp[i - 1][j] + 1,    // Deletion
// //         dp[i][j - 1] + 1,    // Insertion
// //         dp[i - 1][j - 1] + cost // Substitution
// //       ].reduce((a, b) => a < b ? a : b);
// //     }
// //   }
// //   return dp[s1.length][s2.length];
// // }

import 'package:flutter/material.dart';
// import 'package:firetown/models/json_serializable_abstract_class.dart';

// @immutable
// class TownStorage implements JsonSerializable{
//   final String id;
//   final String townName;
//   final Map<String,dynamic> demographic;

//   @override
//   String compositeKey(){
//     return id;
//   }
//   const TownStorage({required this.id, required this.townName, required this.demographic});

//   @override
//   Map<String,dynamic> toJson()
//   {
//       return {
//         "id": id,
//         "townName": townName,
//         "demographic": demographic
//       };
//   }
//   factory TownStorage.fromJson(json)
//   {
//     return TownStorage(id: json["id"], townName: json["townName"], demographic: json["demographic"]);
//   }


// }

  // Future<void> closeOpen(var boxProvider, String afterDot) async {
    //   await _lock.synchronized(() async {
    //     if (await ref.read(boxProvider).isOpen) {
    //       print("Closing $afterDot");
    //       await ref.read(boxProvider).close();
    //       print("$afterDot Closed√");
    //     }
    //     print("Reading $afterDot");
    //     ref.read(boxProvider.notifier).state = await Hive.openBox<String>(
    //       "$id.$afterDot",
    //     );
    //     print("$afterDot read√");
    //   });
    // }

    // await closeOpen(peopleBoxProvider, "people");
    // await closeOpen(relBoxProvider, "relationships");
    // await closeOpen(locationsRoleBoxProvider, "locRole");
    // await closeOpen(locationBoxProvider, "locations");
    // await closeOpen(peopleSearchBoxProvider, "peopleSearch");
    // await closeOpen(locationSearchBoxProvider, "locationSearch");
    // await closeOpen(pendingRolesBoxProvider, "pendingRoles");

    // List<TownStorage> myTowns = ref.read(myTownsProvider);
    // String myName = myTowns.firstWhere((v) => v.id == id).townName;
    // Map<String, int> myDemo = (myTowns
    //         .firstWhere((v) => v.id == id)
    //         .demographic)
    //     .map((key, value) => MapEntry(key, value as int));
    // ref.read(townProvider.notifier).state = TownOnFire(
    //   name: myName,
    //   id: id,
    //   myDemographics: myDemo,
    // );
    // List<RoleGeneration> miku = await ref.read(allRoles);

    // roleLookup.addAll({
    //   LocationType.info:
    //       miku.where((e) => e.informational).map((e) => e.thisRole).toList(),
    //   LocationType.hireling:
    //       miku.where((e) => e.informational).map((e) => e.thisRole).toList(),
    //   LocationType.market:
    //       miku.where((e) => e.informational).map((e) => e.thisRole).toList(),
    // });